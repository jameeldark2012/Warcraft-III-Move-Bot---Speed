//==================================================================================================
//  $Id: common.ai,v 1.68 2003/05/12 02:34:18 bfitch Exp $
//==================================================================================================
/**
@patch 1.00
*/
native DebugS               takes string str                            returns nothing
/**
@patch 1.00
*/
native DebugFI              takes string str, integer val               returns nothing
/**
@patch 1.00
*/
native DebugUnitID          takes string str, integer val               returns nothing
/**
@patch 1.00
*/
native DisplayText          takes integer p, string str                 returns nothing
/**
@patch 1.00
*/
native DisplayTextI         takes integer p, string str, integer val    returns nothing
/**
@patch 1.07
*/
native DisplayTextII        takes integer p, string str, integer v1, integer v2 returns nothing

/**
Does nothing in release build v1.33.
@patch 1.07
*/
native DisplayTextIII       takes integer p, string str, integer v1, integer v2, integer v3 returns nothing
/**
@patch 1.00
*/
native DoAiScriptDebug      takes nothing                               returns boolean

/**
@patch 1.00
*/
native GetAiPlayer          takes nothing                               returns integer

/**
Returns the ID of the leveled up hero, so it can be used in the heroes levels code function
(probably `SetHeroLevels`).
@patch 1.00
*/
native GetHeroId            takes nothing                               returns integer

/**
Returns the level of the leveling hero so it can be used in the heroes levels code function
(probably `SetHeroLevels`).
@patch 1.00
*/
native GetHeroLevelAI       takes nothing                               returns integer


/**
Counts units of type for the AI player whether it is trained/built or in progress.

@param unitid Rawcode to specify unit type to count

@note See: `GetUnitCountDone`
@patch 1.00
*/
native GetUnitCount         takes integer unitid                        returns integer

/**
Returns how many `unit`s of a certain type a `player` has.

@commonai
@patch 1.00
*/
native GetPlayerUnitTypeCount takes player p, integer unitid            returns integer

/**
Counts units of type for the AI player that is trained/built or in progress.

@param unitid Rawcode to specify unit type to count

@note See: `GetUnitCount`
@patch 1.00
*/
native GetUnitCountDone     takes integer unitid                        returns integer

/**
Counts buildings of specific type for the AI player in a town.

@param id Rawcode to specify unit type to count
@param tn ID of target town
@param dn If true: only count finished units

@note This will return 0 for `tn = -1` and will only work for buildings; normal units will always return 0.
@patch 1.00
*/
native GetTownUnitCount     takes integer id, integer tn, boolean dn    returns integer

/**
Gets the gold cost of a unit-type.

@param unitid Rawcode to specify unit type

@bug Crashes the game for hero ids (tested in a normal script).

@commonai
@patch 1.00
*/
native GetUnitGoldCost      takes integer unitid                        returns integer

/**
Gets the lumber cost of a unit-type.

@param unitid Rawcode to specify unit type

@bug Crashes the game for hero ids (tested in a normal script).

@commonai
@patch 1.00
*/
native GetUnitWoodCost      takes integer unitid                        returns integer

/**
Gets the building time of a unit-type.

@param unitid Rawcode to specify unit type

@commonai
@patch 1.07
*/
native GetUnitBuildTime     takes integer unitid                        returns integer

/**
@patch 1.00
*/
native GetMinesOwned        takes nothing                               returns integer
/**
@patch 1.00
*/
native GetGoldOwned         takes nothing                               returns integer
/**
@patch 1.00
*/
native TownWithMine         takes nothing                               returns integer
/**
@patch 1.00
*/
native TownHasMine          takes integer townid                        returns boolean
/**
@patch 1.00
*/
native TownHasHall          takes integer townid                        returns boolean

/**
@patch 1.00
*/
native GetUpgradeLevel      takes integer id                            returns integer
/**
@patch 1.00
*/
native GetUpgradeGoldCost   takes integer id                            returns integer
/**
@patch 1.00
*/
native GetUpgradeWoodCost   takes integer id                            returns integer
/**
@patch 1.00
*/
native GetNextExpansion     takes nothing                               returns integer
/**
@patch 1.00
*/
native GetMegaTarget        takes nothing                               returns unit

/**
Get the last constructed or pre-placed building for the given player.

@note For pre-placed buildings the order is the number that you find in the WE.
Example: Blacksmith_0023, Workshop_0065, then the last building will be Workshop_0065,
but if a peasent in game constructed an altar then that will be the last building.

@note Player `p` can be a human controlled player not necessarily computer.

@param p Target player

@commonai
@patch 1.00
*/
native GetBuilding          takes player p                              returns unit
/**
@patch 1.00
*/
native GetEnemyPower        takes nothing                               returns integer
/**
@patch 1.00
*/
native SetAllianceTarget    takes unit id                               returns nothing
/**
@patch 1.00
*/
native GetAllianceTarget    takes nothing                               returns unit

/**
Trains unit(s) of specified type at target town.

Returns true if the unit can be trained successfully, i.e. the AI player has all the resources and requirments of the training as well as the building that will start the training.

@note The parameter `qty` will only work if the player has `qty` amount of buildings that can train this unit.

However this action *will not queue*.
Example: the player has 1 barracks and `qty = 3` then 1 unit will be trained.
Lets suppose that another barracks is built then 2 units will be trained.

@param qty Select this many buildings (e.g. Barracks) to train units in
@param id Rawcode to specify unit type to train
@param town Index of town
@patch 1.00
*/
native SetProduce           takes integer qty, integer id, integer town returns boolean
/**
@patch 1.00
*/
native Unsummon             takes unit unitid                           returns nothing
/**
@patch 1.00
*/
native SetExpansion         takes unit peon, integer id                 returns boolean

/**
Starts an upgrade for the AI player.

Return true if the upgrade has started successfully, i.e. the AI player has all the resources and requirments of the upgrade as well as the building that will start the upgrade.

@param id Rawcode of the upgrade to be researched
@patch 1.00
*/
native SetUpgrade           takes integer id                            returns boolean

/**
This native will set how the heroes of the AI player will allocate their skill points as defined in the code function `func`.
@patch 1.00
*/
native SetHeroLevels        takes code func                             returns nothing
/**
@patch 1.00
*/
native SetNewHeroes         takes boolean state                         returns nothing

/**
Purchace a zeppelin, must be called when a hero is standing near a goblin lab.
@patch 1.00
*/
native PurchaseZeppelin     takes nothing                               returns nothing

/**
Merges two units, who can be merged, like the hippogryph rider. The use of this native gives better response if called from inside a loop.
@patch 1.00
*/
native MergeUnits           takes integer qty, integer a, integer b, integer make returns boolean

/**
This native have the same effect on units like the obsidian statue when converted to destroyer. The use of this native gives better response if called from inside a loop.
@patch 1.07
*/
native ConvertUnits         takes integer qty, integer id               returns boolean

/**
@patch 1.00
*/
native SetCampaignAI        takes nothing                               returns nothing
/**
@patch 1.00
*/
native SetMeleeAI           takes nothing                               returns nothing

/**
Toggle the feature of making the AI target heroes. 

Gives priority to target heroes if enabled.

@param state True: turned on. False: turned off.
@patch 1.00
*/
native SetTargetHeroes      takes boolean state                         returns nothing

/**
Toggle the feature of making peons to repair damaged structures and mechanical units.

@param state True: turned on. False: turned off.
@patch 1.00
*/
native SetPeonsRepair       takes boolean state                         returns nothing
/**
@patch 1.07
*/
native SetRandomPaths       takes boolean state                         returns nothing
/**
@patch 1.07
*/
native SetDefendPlayer      takes boolean state                         returns nothing

/**
Toggle the feature of making the heroes flee when they are seriously damaged.

@param state True: turned on. False: turned off.
@patch 1.00
*/
native SetHeroesFlee        takes boolean state                         returns nothing

/**
Toggle the feature of making the heroes buy items.

@param state True: turned on. False: turned off.
@patch 1.07
*/
native SetHeroesBuyItems    takes boolean state                         returns nothing
/**
@patch 1.00
*/
native SetWatchMegaTargets  takes boolean state                         returns nothing
/**
@patch 1.00
*/
native SetIgnoreInjured     takes boolean state                         returns nothing

/**
Toggle the feature of making the heroes take items.

@param state True: turned on. False: turned off.
@patch 1.00
*/
native SetHeroesTakeItems   takes boolean state                         returns nothing

/**
Toggle the feature of making the units flee when they are seriously damaged.

@param state True: turned on. False: turned off.
@patch 1.00
*/
native SetUnitsFlee         takes boolean state                         returns nothing

/**
Toggle the feature of making the entire group flee when it is seriously damaged.

@param state True: turned on. False: turned off.
@patch 1.00
*/
native SetGroupsFlee        takes boolean state                         returns nothing

/**
If true the gold harvested by the AI player peons will be 1 per period, instead of 10 per period for false state.
@patch 1.00
*/
native SetSlowChopping      takes boolean state                         returns nothing
/**
@patch 1.00
*/
native SetCaptainChanges    takes boolean allow                         returns nothing
/**
@patch 1.00
*/
native SetSmartArtillery    takes boolean state                         returns nothing

/**
Replaces every AI's player pre-placed units or units that are assigned to a guard posts N times when it is killed.

@note This only works for units not classified as workers and will not work for peon-type (Peasants, Peons, Acolytes, Wisps and Mur'gul Slaves) even if not classified as workers.
@patch 1.00
*/
native SetReplacementCount  takes integer qty                           returns nothing
/**
@patch 1.00
*/
native GroupTimedLife       takes boolean allow                         returns nothing
/**
@patch 1.00
*/
native RemoveInjuries       takes nothing                               returns nothing
/**
@patch 1.00
*/
native RemoveSiege          takes nothing                               returns nothing

/**
@patch 1.00
*/
native InitAssault          takes nothing                               returns nothing

/**
Creates a group from already-existing units that can be assigned to attack a specific target.
When `AttackMoveXY` is called then this group will attack the specified target.

@note Important: in order to use this native, `CreateCaptains` must be called first or the game will crash. It is already called in the function `CampaignAI` found in `common.ai`.
@patch 1.00
*/
native AddAssault           takes integer qty, integer id               returns boolean

/**
Creates a group from already-existing units to guard the AI player town. The units assemble around the most important building in the town with no specific formation.

@note Important: in order to use this native, `CreateCaptains` must be called first or the game will crash. It is already called in the function `CampaignAI` found in `common.ai`.
@patch 1.00
*/
native AddDefenders         takes integer qty, integer id               returns boolean

/**
Searches for the nearest creep camp, the parameters defines the power of the camp.

The power is the total level of all creeps. For example, lets say `min = 3` and `max = 3` then the camp that will be detected will have 3 possibilities:

1. 3 creeps of level 1
2. 1 creep of level 3
3. 1 creep of level 2 and 1 creep of level 1

@param min Minimal power allowed
@param max Maximum power allowed
@param flyers_ok Filter by flying units in the camp. Set to true to allow flying and false for ground units only.
@patch 1.00
*/
native GetCreepCamp         takes integer min, integer max, boolean flyers_ok returns unit

/**
Must be called before using the native `GetEnemyBase` in order to make it work.
@patch 1.00
*/
native StartGetEnemyBase    takes nothing                               returns nothing
/**
@patch 1.00
*/
native WaitGetEnemyBase     takes nothing                               returns boolean

/**
Returns the enemy base unit. Must call `StartGetEnemyBase` first or it will return null.
@patch 1.00
*/
native GetEnemyBase         takes nothing                               returns unit

/**
Returns an enemy unit near the expansion location, whether this unit is a creep or belong to an enemy to the AI player.

@note Important: in order to use this native, `CreateCaptains` must be called first or the game will crash. It is already called in the function `CampaignAI` found in `common.ai`.
@patch 1.00
*/
native GetExpansionFoe      takes nothing                               returns unit

/**
Returns the enemy expansion base.
@patch 1.00
*/
native GetEnemyExpansion    takes nothing                               returns unit

/**
Returns the integer X coordinate of the AI player expansion location whether it is constructed or not.

@note Important: in order to use this native, `CreateCaptains` must be called first or the game will crash. It is already called in the function `CampaignAI` found in `common.ai`.
@patch 1.00
*/
native GetExpansionX        takes nothing                               returns integer

/**
Returns the integer Y coordinate of the AI player expansion location whether it is constructed or not.

@note Important: in order to use this native, `CreateCaptains` must be called first or the game will crash. It is already called in the function `CampaignAI` found in `common.ai`.
@patch 1.00
*/
native GetExpansionY        takes nothing                               returns integer
/**
@patch 1.00
*/
native SetStagePoint        takes real x, real y                        returns nothing
/**
@patch 1.00
*/
native AttackMoveKill       takes unit target                           returns nothing

/**
Pings a location on the mini-map where 'unit' intends to attack-move this unit.

If `AddAssault` is not called before this one, then the units (**if any**) will remain at their position and will not attack-move the signaled unit. Once the units go to the unit they will return to the base when the unit is killed.

If they didn't find any enemy on their route or it if is destroyed and at least one unit survived in the group.

@note Important: in order to use this native, the native `CreateCaptains` must be called first or the game will crash. It is already added in the function CampaignAI found at `common.ai`
@patch 1.00
*/
native AttackMoveXY         takes integer x, integer y                  returns nothing
/**
@patch 1.07
*/
native LoadZepWave          takes integer x, integer y                  returns nothing
/**
@patch 1.00
*/
native SuicidePlayer        takes player id, boolean check_full         returns boolean
/**
@patch 1.07
*/
native SuicidePlayerUnits   takes player id, boolean check_full         returns boolean
/**
@patch 1.00
*/
native CaptainInCombat      takes boolean attack_captain                returns boolean

/**
Returns either true if the parameter target is guarded by a tower, the tower can be a custom-made unit but there are rules when checking if the target is guarded or not; the target has to be in the proximity of a base and a tower belonging to the AI player, however acquisition range and attack range of the tower doesn't affect whether the target is defended or not.
@patch 1.00
*/
native IsTowered            takes unit target                           returns boolean

/**
@patch 1.00
*/
native ClearHarvestAI       takes nothing                               returns nothing

/**
Order peons to harvest a gold mine in the town.

@param town Index ID of town
@param peons Amount of peons
@patch 1.00
*/
native HarvestGold          takes integer town, integer peons           returns nothing

/**
Order peons to harvest trees near the town.

@param town Index ID of town
@param peons Amount of peons
@patch 1.00
*/
native HarvestWood          takes integer town, integer peons           returns nothing

/**
Returns the peon unit that will start a new expansion for the AI player, however, it will return null if there is no gold mine (excluding a gold mine the AI player already own) found on the map.

@note Important: in order to use this native, `CreateCaptains` must be called first or the game will crash. It is already called in the function `CampaignAI` found in `common.ai`.
@patch 1.00
*/
native GetExpansionPeon     takes nothing                               returns unit


/**
This native must be called at the start of an AI file so that the following native `FillGuardPosts` works, if not then `FillGuardPosts` will continuosly train units if it is nested in a loop and also will cause the trained units not to go to replace the killed ones, instead they will remain near the building that trained them.
@patch 1.00
*/
native StopGathering        takes nothing                               returns nothing

/**
This marks a spot at point (x,y) as a guard post and a unit of specified type will be
guarding that spot.
The spot will remain empty until the function `FillGuardPosts` is called, after that
the specified unit will go to guard that spot. If the unit is killed another one will replace it.
However, this process is not unlimited, by default, the unit is replaced 3 times
but if the native `SetReplacementCount(N)` is called in the AI script the unit will be
replaced N times. Note that if this is used on heroes they will be trained only but will not
go to the post.

@param id Rawcode for unit type of the guard unit
@patch 1.00
*/
native AddGuardPost         takes integer id, real x, real y            returns nothing

/**
When called, a unit of the same type of the last killed unit that belong to the AI player will be trained and replace the previous one.

@note This native is instant and will not queue, so in order to keep replacing killed units,
it has to be nested inside a continuous loop.
@patch 1.00
*/
native FillGuardPosts       takes nothing                               returns nothing

/**
Order every unit that is assigned a guard post to return to it. This native works for pre-placed units and newly trained ones. 

@note There is a small tolerance of 82.006 radius offset to the guard post.
@patch 1.00
*/
native ReturnGuardPosts     takes nothing                               returns nothing
/**
@patch 1.00
*/
native CreateCaptains       takes nothing                               returns nothing
/**
@patch 1.00
*/
native SetCaptainHome       takes integer which, real x, real y         returns nothing
/**
@patch 1.07
*/
native ResetCaptainLocs     takes nothing                               returns nothing
/**
@patch 1.00
*/
native ShiftTownSpot        takes real x, real y                        returns nothing
/**
@patch 1.00
*/
native TeleportCaptain      takes real x, real y                        returns nothing
/**
@patch 1.00
*/
native ClearCaptainTargets  takes nothing                               returns nothing
/**
@patch 1.00
*/
native CaptainAttack        takes real x, real y                        returns nothing
/**
@patch 1.00
*/
native CaptainVsUnits       takes player id                             returns nothing
/**
@patch 1.00
*/
native CaptainVsPlayer      takes player id                             returns nothing
/**
@patch 1.00
*/
native CaptainGoHome        takes nothing                               returns nothing
/**
@patch 1.00
*/
native CaptainIsHome        takes nothing                               returns boolean
/**
@patch 1.00
*/
native CaptainIsFull        takes nothing                               returns boolean
/**
@patch 1.00
*/
native CaptainIsEmpty       takes nothing                               returns boolean
/**
@patch 1.00
*/
native CaptainGroupSize     takes nothing                               returns integer
/**
@patch 1.00
*/
native CaptainReadiness     takes nothing                               returns integer
/**
@patch 1.00
*/
native CaptainRetreating    takes nothing                               returns boolean
/**
@patch 1.00
*/
native CaptainReadinessHP   takes nothing                               returns integer
/**
@patch 1.00
*/
native CaptainReadinessMa   takes nothing                               returns integer
/**
@patch 1.00
*/
native CaptainAtGoal        takes nothing                               returns boolean

/**
Returns `true` if any units of any level on the map have the classification of creep.

@commonai
@patch 1.00
*/
native CreepsOnMap          takes nothing                               returns boolean
/**
@patch 1.00
*/
native SuicideUnit          takes integer count, integer unitid         returns nothing
/**
@patch 1.00
*/
native SuicideUnitEx        takes integer ct, integer uid, integer pid  returns nothing
/**
@patch 1.00
*/
native StartThread          takes code func                             returns nothing
/**
@patch 1.00
*/
native Sleep                takes real seconds                          returns nothing

/**
Checks if a unit is alive.

@commonai
@patch 1.00
*/
native UnitAlive            takes unit id                               returns boolean

/**
Checks if a unit is invisible.

@commonai
@patch 1.07
*/
native UnitInvis            takes unit id                               returns boolean
/**
@patch 1.00
*/
native IgnoredUnits         takes integer unitid                        returns integer

/**
Although the name suggests otherwise, this returns true if any unit (building or unit) for the AI player is being attacked.
@patch 1.07
*/
native TownThreatened       takes nothing                               returns boolean
/**
@patch 1.07
*/
native DisablePathing       takes nothing                               returns nothing
/**
@patch 1.07
*/
native SetAmphibious        takes nothing                               returns nothing

/**
Every time you use the trigger action 'Send AI Command' the command queue counter 
increases by 1.
This has nothing to do with the value of the command in the argument of the
trigger action; so sending an AI signal with (1,0) is like (5,0) everyone will increase the
counter by 1.

@note See: `GetLastCommand`, `GetLastData`, `PopLastCommand`
@patch 1.00
*/
native CommandsWaiting      takes nothing                               returns integer

/**
When an AI signal is sent via triggers, this returns the command value.
So sending an AI signal of (5,3) returns 5.

@note See: `CommandsWaiting` `GetLastData`, `PopLastCommand`
@patch 1.00
*/
native GetLastCommand       takes nothing                               returns integer

/**
The same as `GetLastCommand` but it returns the data value.
For the previous example, it will return 3.

@note See: `CommandsWaiting`, `GetLastCommand`, `PopLastCommand`
@patch 1.00
*/
native GetLastData          takes nothing                               returns integer

/**
Reduce the command queue counter by 1. It's important to pop last command because many sleep function in `common.ai` exits when the value of the command counter not equal to zero.

@note See: `CommandsWaiting`, `GetLastCommand`, `GetLastData`
@patch 1.00
*/
native PopLastCommand       takes nothing                               returns nothing
/**
@patch 1.03
*/
native MeleeDifficulty      takes nothing                               returns integer

//============================================================================
//  Globals for all AI scripts
//============================================================================
globals

    //--------------------------------------------------------------------
    //  HUMANS
    //--------------------------------------------------------------------

    // human heroes
/**
@patch 1.00
*/
    constant integer ARCHMAGE           = 'Hamg'
/**
@patch 1.00
*/
    constant integer PALADIN            = 'Hpal'
/**
@patch 1.00
*/
    constant integer MTN_KING           = 'Hmkg'
/**
@patch 1.07
*/
    constant integer BLOOD_MAGE         = 'Hblm'

    // human hero abilities
/**
@patch 1.00
*/
    constant integer AVATAR             = 'AHav'
/**
@patch 1.00
*/
    constant integer BASH               = 'AHbh'
/**
@patch 1.00
*/
    constant integer THUNDER_BOLT       = 'AHtb'
/**
@patch 1.00
*/
    constant integer THUNDER_CLAP       = 'AHtc'

/**
@patch 1.00
*/
    constant integer DEVOTION_AURA      = 'AHad'
/**
@patch 1.00
*/
    constant integer DIVINE_SHIELD      = 'AHds'
/**
@patch 1.00
*/
    constant integer HOLY_BOLT          = 'AHhb'
/**
@patch 1.00
*/
    constant integer RESURRECTION       = 'AHre'

/**
@patch 1.00
*/
    constant integer BLIZZARD           = 'AHbz'
/**
@patch 1.00
*/
    constant integer BRILLIANCE_AURA    = 'AHab'
/**
@patch 1.00
*/
    constant integer MASS_TELEPORT      = 'AHmt'
/**
@patch 1.00
*/
    constant integer WATER_ELEMENTAL    = 'AHwe'

/**
@patch 1.07
*/
    constant integer BANISH             = 'AHbn'
/**
@patch 1.07
*/
    constant integer FLAME_STRIKE       = 'AHfs'
/**
@patch 1.07
*/
    constant integer SUMMON_PHOENIX     = 'AHpx'
/**
@patch 1.07
*/
    constant integer SIPHON_MANA        = 'AHdr'

    // special human heroes
/**
@patch 1.00
*/
    constant integer JAINA              = 'Hjai'
/**
@patch 1.00
*/
    constant integer MURADIN            = 'Hmbr'
/**
@patch 1.07
*/
    constant integer GARITHOS           = 'Hlgr'
/**
@patch 1.07
*/
    constant integer KAEL               = 'Hkal'

    // human units
/**
@patch 1.00
*/
    constant integer COPTER             = 'hgyr'
/**
@patch 1.07
*/
    constant integer GYRO               =  COPTER
/**
@patch 1.00
*/
    constant integer ELEMENTAL          = 'hwat'
/**
@patch 1.00
*/
    constant integer FOOTMAN            = 'hfoo'
/**
@patch 1.00
*/
    constant integer FOOTMEN            =  FOOTMAN
/**
@patch 1.00
*/
    constant integer GRYPHON            = 'hgry'
/**
@patch 1.00
*/
    constant integer KNIGHT             = 'hkni'
/**
@patch 1.00
*/
    constant integer MORTAR             = 'hmtm'
/**
@patch 1.00
*/
    constant integer PEASANT            = 'hpea'
/**
@patch 1.00
*/
    constant integer PRIEST             = 'hmpr'
/**
@patch 1.00
*/
    constant integer RIFLEMAN           = 'hrif'
/**
@patch 1.00
*/
    constant integer RIFLEMEN           =  RIFLEMAN
/**
@patch 1.00
*/
    constant integer SORCERESS          = 'hsor'
/**
@patch 1.00
*/
    constant integer TANK               = 'hmtt'
/**
@patch 1.07
*/
    constant integer STEAM_TANK         =  TANK
/**
@patch 1.07
*/
    constant integer ROCKET_TANK        = 'hrtt'
/**
@patch 1.00
*/
    constant integer MILITIA            = 'hmil'
/**
@patch 1.07
*/
    constant integer SPELL_BREAKER      = 'hspt'
/**
@patch 1.07
*/
    constant integer HUMAN_DRAGON_HAWK  = 'hdhw'

    // special human units
/**
@patch 1.07
*/
    constant integer BLOOD_PRIEST       = 'hbep'
/**
@patch 1.07
*/
    constant integer BLOOD_SORCERESS    = 'hbes'
/**
@patch 1.07
*/
    constant integer BLOOD_PEASANT      = 'nhew'

    // human buildings
/**
@patch 1.00
*/
    constant integer AVIARY             = 'hgra'
/**
@patch 1.00
*/
    constant integer BARRACKS           = 'hbar'
/**
@patch 1.00
*/
    constant integer BLACKSMITH         = 'hbla'
/**
@patch 1.00
*/
    constant integer CANNON_TOWER       = 'hctw'
/**
@patch 1.00
*/
    constant integer CASTLE             = 'hcas'
/**
@patch 1.00
*/
    constant integer CHURCH             = 'htws'
/**
@patch 1.00
*/
    constant integer MAGE_TOWER         =  CHURCH
/**
@patch 1.00
*/
    constant integer GUARD_TOWER        = 'hgtw'
/**
@patch 1.00
*/
    constant integer HOUSE              = 'hhou'
/**
@patch 1.00
*/
    constant integer HUMAN_ALTAR        = 'halt'
/**
@patch 1.00
*/
    constant integer KEEP               = 'hkee'
/**
@patch 1.00
*/
    constant integer LUMBER_MILL        = 'hlum'
/**
@patch 1.00
*/
    constant integer SANCTUM            = 'hars'
/**
@patch 1.07
*/
    constant integer ARCANE_SANCTUM     =  SANCTUM
/**
@patch 1.00
*/
    constant integer TOWN_HALL          = 'htow'
/**
@patch 1.00
*/
    constant integer WATCH_TOWER        = 'hwtw'
/**
@patch 1.00
*/
    constant integer WORKSHOP           = 'harm'
/**
@patch 1.07
*/
    constant integer ARCANE_VAULT       = 'hvlt'
/**
@patch 1.07
*/
    constant integer ARCANE_TOWER       = 'hatw'

    // human upgrades
/**
@patch 1.00
*/
    constant integer UPG_MELEE          = 'Rhme'
/**
@patch 1.00
*/
    constant integer UPG_RANGED         = 'Rhra'
/**
@patch 1.00
*/
    constant integer UPG_ARTILLERY      = 'Rhaa'
/**
@patch 1.00
*/
    constant integer UPG_ARMOR          = 'Rhar'
/**
@patch 1.00
*/
    constant integer UPG_GOLD           = 'Rhmi'
/**
@patch 1.00
*/
    constant integer UPG_MASONRY        = 'Rhac'
/**
@patch 1.00
*/
    constant integer UPG_SIGHT          = 'Rhss'
/**
@patch 1.00
*/
    constant integer UPG_DEFEND         = 'Rhde'
/**
@patch 1.00
*/
    constant integer UPG_BREEDING       = 'Rhan'
/**
@patch 1.00
*/
    constant integer UPG_PRAYING        = 'Rhpt'
/**
@patch 1.00
*/
    constant integer UPG_SORCERY        = 'Rhst'
/**
@patch 1.00
*/
    constant integer UPG_LEATHER        = 'Rhla'
/**
@patch 1.00
*/
    constant integer UPG_GUN_RANGE      = 'Rhri'
/**
@patch 1.00
*/
    constant integer UPG_WOOD           = 'Rhlh'
/**
@patch 1.00
*/
    constant integer UPG_SENTINEL       = 'Rhse'
/**
@patch 1.00
*/
    constant integer UPG_SCATTER        = 'Rhsr'
/**
@patch 1.00
*/
    constant integer UPG_BOMBS          = 'Rhgb'
/**
@patch 1.00
*/
    constant integer UPG_HAMMERS        = 'Rhhb'
/**
@patch 1.07
*/
    constant integer UPG_CONT_MAGIC     = 'Rhss'
/**
@patch 1.07
*/
    constant integer UPG_FRAGS          = 'Rhfs'
/**
@patch 1.07
*/
    constant integer UPG_TANK           = 'Rhrt'
/**
@patch 1.07
*/
    constant integer UPG_FLAK           = 'Rhfc'
/**
@patch 1.07
*/
    constant integer UPG_CLOUD          = 'Rhcd'

    //--------------------------------------------------------------------
    //  ORCS
    //--------------------------------------------------------------------

    // orc heroes
/**
@patch 1.00
*/
    constant integer BLADE_MASTER       = 'Obla'
/**
@patch 1.00
*/
    constant integer FAR_SEER           = 'Ofar'
/**
@patch 1.00
*/
    constant integer TAUREN_CHIEF       = 'Otch'
/**
@patch 1.07
*/
    constant integer SHADOW_HUNTER      = 'Oshd'

    // special orc heroes
/**
@patch 1.00
*/
    constant integer GROM               = 'Ogrh'
/**
@patch 1.00
*/
    constant integer THRALL             = 'Othr'

    // orc hero abilities
/**
@patch 1.00
*/
    constant integer CRITICAL_STRIKE    = 'AOcr'
/**
@patch 1.00
*/
    constant integer MIRROR_IMAGE       = 'AOmi'
/**
@patch 1.00
*/
    constant integer BLADE_STORM        = 'AOww'
/**
@patch 1.00
*/
    constant integer WIND_WALK          = 'AOwk'

/**
@patch 1.00
*/
    constant integer CHAIN_LIGHTNING    = 'AOcl'
/**
@patch 1.00
*/
    constant integer EARTHQUAKE         = 'AOeq'
/**
@patch 1.00
*/
    constant integer FAR_SIGHT          = 'AOfs'
/**
@patch 1.00
*/
    constant integer SPIRIT_WOLF        = 'AOsf'

/**
@patch 1.00
*/
    constant integer ENDURANE_AURA      = 'AOae'
/**
@patch 1.00
*/
    constant integer REINCARNATION      = 'AOre'
/**
@patch 1.00
*/
    constant integer SHOCKWAVE          = 'AOsh'
/**
@patch 1.00
*/
    constant integer WAR_STOMP          = 'AOws'

/**
@patch 1.07
*/
    constant integer HEALING_WAVE       = 'AOhw'
/**
@patch 1.07
*/
    constant integer HEX                = 'AOhx'
/**
@patch 1.07
*/
    constant integer SERPENT_WARD       = 'AOsw'
/**
@patch 1.07
*/
    constant integer VOODOO             = 'AOvd'

    // orc units
/**
@patch 1.00
*/
    constant integer GUARDIAN           = 'oang'
/**
@patch 1.00
*/
    constant integer CATAPULT           = 'ocat'
/**
@patch 1.00
*/
    constant integer WITCH_DOCTOR       = 'odoc'
/**
@patch 1.00
*/
    constant integer GRUNT              = 'ogru'
/**
@patch 1.00
*/
    constant integer HEAD_HUNTER        = 'ohun'
/**
@patch 1.07
*/
    constant integer BERSERKER          = 'otbk'
/**
@patch 1.00
*/
    constant integer KODO_BEAST         = 'okod'
/**
@patch 1.00
*/
    constant integer PEON               = 'opeo'
/**
@patch 1.00
*/
    constant integer RAIDER             = 'orai'
/**
@patch 1.00
*/
    constant integer SHAMAN             = 'oshm'
/**
@patch 1.00
*/
    constant integer TAUREN             = 'otau'
/**
@patch 1.00
*/
    constant integer WYVERN             = 'owyv'
/**
@patch 1.07
*/
    constant integer BATRIDER           = 'otbr'
/**
@patch 1.07
*/
    constant integer SPIRIT_WALKER      = 'ospw'
/**
@patch 1.07
*/
    constant integer SPIRIT_WALKER_M    = 'ospm'

    // orc buildings
/**
@patch 1.00
*/
    constant integer ORC_ALTAR          = 'oalt'
/**
@patch 1.00
*/
    constant integer ORC_BARRACKS       = 'obar'
/**
@patch 1.00
*/
    constant integer BESTIARY           = 'obea'
/**
@patch 1.00
*/
    constant integer FORGE              = 'ofor'
/**
@patch 1.00
*/
    constant integer FORTRESS           = 'ofrt'
/**
@patch 1.00
*/
    constant integer GREAT_HALL         = 'ogre'
/**
@patch 1.00
*/
    constant integer LODGE              = 'osld'
/**
@patch 1.00
*/
    constant integer STRONGHOLD         = 'ostr'
/**
@patch 1.00
*/
    constant integer BURROW             = 'otrb'
/**
@patch 1.00
*/
    constant integer TOTEM              = 'otto'
/**
@patch 1.00
*/
    constant integer ORC_WATCH_TOWER    = 'owtw'
/**
@patch 1.07
*/
    constant integer VOODOO_LOUNGE      = 'ovln'

    // orc upgrades
/**
@patch 1.00
*/
    constant integer UPG_ORC_MELEE      = 'Rome'
/**
@patch 1.00
*/
    constant integer UPG_ORC_RANGED     = 'Rora'
/**
@patch 1.00
*/
    constant integer UPG_ORC_ARTILLERY  = 'Roaa'
/**
@patch 1.00
*/
    constant integer UPG_ORC_ARMOR      = 'Roar'
/**
@patch 1.00
*/
    constant integer UPG_ORC_WAR_DRUMS  = 'Rwdm'
/**
@patch 1.00
*/
    constant integer UPG_ORC_PILLAGE    = 'Ropg'
/**
@patch 1.00
*/
    constant integer UPG_ORC_BERSERK    = 'Robs'
/**
@patch 1.00
*/
    constant integer UPG_ORC_PULVERIZE  = 'Rows'
/**
@patch 1.00
*/
    constant integer UPG_ORC_ENSNARE    = 'Roen'
/**
@patch 1.00
*/
    constant integer UPG_ORC_VENOM      = 'Rovs'
/**
@patch 1.00
*/
    constant integer UPG_ORC_DOCS       = 'Rowd'
/**
@patch 1.00
*/
    constant integer UPG_ORC_SHAMAN     = 'Rost'
/**
@patch 1.00
*/
    constant integer UPG_ORC_SPIKES     = 'Rosp'
/**
@patch 1.07
*/
    constant integer UPG_ORC_BURROWS    = 'Rorb'
/**
@patch 1.00
*/
    constant integer UPG_ORC_REGEN      = 'Rotr'
/**
@patch 1.07
*/
    constant integer UPG_ORC_FIRE       = 'Rolf'
/**
@patch 1.07
*/
    constant integer UPG_ORC_SWALKER    = 'Rowt'
/**
@patch 1.07
*/
    constant integer UPG_ORC_BERSERKER  = 'Robk'
/**
@patch 1.07
*/
    constant integer UPG_ORC_NAPTHA     = 'Robf'
/**
@patch 1.07
*/
    constant integer UPG_ORC_CHAOS      = 'Roch'

    // Warcraft 2 orc units
/**
@patch 1.00
*/
    constant integer OGRE_MAGI          = 'nomg'
/**
@patch 1.00
*/
    constant integer ORC_DRAGON         = 'nrwm'
/**
@patch 1.00
*/
    constant integer SAPPER             = 'ngsp'
/**
@patch 1.00
*/
    constant integer ZEPPLIN            = 'nzep'
/**
@patch 1.00
*/
    constant integer ZEPPELIN           =  ZEPPLIN
/**
@patch 1.00
*/
    constant integer W2_WARLOCK         = 'nw2w'
/**
@patch 1.00
*/
    constant integer PIG_FARM           = 'npgf'
/**
@patch 1.32.0.13369
*/
    constant integer FOREST_TROLL       = 'nftr'
/**
@patch 1.32.10.19202
*/
	constant integer DRAGON_ROOST       = 'ndrb'

    // special orc units
/**
@patch 1.00
*/
    constant integer CHAOS_GRUNT        = 'nchg'
/**
@patch 1.00
*/
    constant integer CHAOS_WARLOCK      = 'nchw'
/**
@patch 1.00
*/
    constant integer CHAOS_RAIDER       = 'nchr'
/**
@patch 1.00
*/
    constant integer CHAOS_PEON         = 'ncpn'
/**
@patch 1.00
*/
    constant integer CHAOS_KODO         = 'nckb'
/**
@patch 1.07
*/
    constant integer CHAOS_GROM         = 'Opgh'
/**
@patch 1.07
*/
    constant integer CHAOS_BLADEMASTER  = 'Nbbc'
/**
@patch 1.07
*/
    constant integer CHAOS_BURROW       = 'ocbw'

    //--------------------------------------------------------------------
    //  UNDEAD
    //--------------------------------------------------------------------

    // undead heroes
/**
@patch 1.00
*/
    constant integer DEATH_KNIGHT       = 'Udea'
/**
@patch 1.00
*/
    constant integer DREAD_LORD         = 'Udre'
/**
@patch 1.00
*/
    constant integer LICH               = 'Ulic'
/**
@patch 1.07
*/
    constant integer CRYPT_LORD         = 'Ucrl'

    // special undead heroes
/**
@patch 1.00
*/
    constant integer MALGANIS           = 'Umal'
/**
@patch 1.00
*/
    constant integer TICHONDRIUS        = 'Utic'
/**
@patch 1.00
*/
    constant integer PIT_LORD           = 'Npld'
/**
@patch 1.07
*/
    constant integer DETHEROC           = 'Udth'

    // undead hero abilities
/**
@patch 1.00
*/
    constant integer SLEEP              = 'AUsl'
/**
@patch 1.00
*/
    constant integer VAMP_AURA          = 'AUav'
/**
@patch 1.00
*/
    constant integer CARRION_SWARM      = 'AUcs'
/**
@patch 1.00
*/
    constant integer INFERNO            = 'AUin'

/**
@patch 1.00
*/
    constant integer DARK_RITUAL        = 'AUdr'
/**
@patch 1.00
*/
    constant integer DEATH_DECAY        = 'AUdd'
/**
@patch 1.00
*/
    constant integer FROST_ARMOR        = 'AUfu'
/**
@patch 1.00
*/
    constant integer FROST_NOVA         = 'AUfn'

/**
@patch 1.00
*/
    constant integer ANIM_DEAD          = 'AUan'
/**
@patch 1.00
*/
    constant integer DEATH_COIL         = 'AUdc'
/**
@patch 1.00
*/
    constant integer DEATH_PACT         = 'AUdp'
/**
@patch 1.00
*/
    constant integer UNHOLY_AURA        = 'AUau'

/**
@patch 1.07
*/
    constant integer CARRION_SCARAB     = 'AUcb'
/**
@patch 1.07
*/
    constant integer IMPALE             = 'AUim'
/**
@patch 1.07
*/
    constant integer LOCUST_SWARM       = 'AUls'
/**
@patch 1.07
*/
    constant integer THORNY_SHIELD      = 'AUts'

    // undead units
/**
@patch 1.00
*/
    constant integer ABOMINATION        = 'uabo'
/**
@patch 1.00
*/
    constant integer ACOLYTE            = 'uaco'
/**
@patch 1.00
*/
    constant integer BANSHEE            = 'uban'
/**
@patch 1.00
*/
    constant integer PIT_FIEND          = 'ucry'
/**
@patch 1.00
*/
    constant integer CRYPT_FIEND        =  PIT_FIEND
/**
@patch 1.00
*/
    constant integer FROST_WYRM         = 'ufro'
/**
@patch 1.00
*/
    constant integer GARGOYLE           = 'ugar'
/**
@patch 1.00
*/
    constant integer GARGOYLE_MORPH     = 'ugrm'
/**
@patch 1.00
*/
    constant integer GHOUL              = 'ugho'
/**
@patch 1.00
*/
    constant integer MEAT_WAGON         = 'umtw'
/**
@patch 1.00
*/
    constant integer NECRO              = 'unec'
/**
@patch 1.00
*/
    constant integer SKEL_WARRIOR       = 'uske'
/**
@patch 1.00
*/
    constant integer SHADE              = 'ushd'
/**
@patch 1.07
*/
    constant integer UNDEAD_BARGE       = 'uarb'
/**
@patch 1.07
*/
    constant integer OBSIDIAN_STATUE    = 'uobs'
/**
@patch 1.07
*/
    constant integer OBS_STATUE         =  OBSIDIAN_STATUE
/**
@patch 1.07
*/
    constant integer BLK_SPHINX         = 'ubsp'

    // undead buildings
/**
@patch 1.00
*/
    constant integer UNDEAD_MINE        = 'ugol'
/**
@patch 1.00
*/
    constant integer UNDEAD_ALTAR       = 'uaod'
/**
@patch 1.00
*/
    constant integer BONEYARD           = 'ubon'
/**
@patch 1.00
*/
    constant integer GARG_SPIRE         = 'ugsp'
/**
@patch 1.00
*/
    constant integer NECROPOLIS_1       = 'unpl'    // normal
/**
@patch 1.00
*/
    constant integer NECROPOLIS_2       = 'unp1'    // upgraded once
/**
@patch 1.00
*/
    constant integer NECROPOLIS_3       = 'unp2'    // full upgrade
/**
@patch 1.00
*/
    constant integer SAC_PIT            = 'usap'
/**
@patch 1.00
*/
    constant integer CRYPT              = 'usep'
/**
@patch 1.00
*/
    constant integer SLAUGHTERHOUSE     = 'uslh'
/**
@patch 1.00
*/
    constant integer DAMNED_TEMPLE      = 'utod'
/**
@patch 1.00
*/
    constant integer ZIGGURAT_1         = 'uzig'    // normal
/**
@patch 1.00
*/
    constant integer ZIGGURAT_2         = 'uzg1'    // upgraded
/**
@patch 1.07
*/
    constant integer ZIGGURAT_FROST     = 'uzg2'    // frost tower
/**
@patch 1.00
*/
    constant integer GRAVEYARD          = 'ugrv'
/**
@patch 1.07
*/
    constant integer TOMB_OF_RELICS     = 'utom'

    // undead upgrades
/**
@patch 1.00
*/
    constant integer UPG_UNHOLY_STR     = 'Rume'
/**
@patch 1.00
*/
    constant integer UPG_CR_ATTACK      = 'Rura'
/**
@patch 1.00
*/
    constant integer UPG_UNHOLY_ARMOR   = 'Ruar'
/**
@patch 1.00
*/
    constant integer UPG_CANNIBALIZE    = 'Ruac'
/**
@patch 1.00
*/
    constant integer UPG_GHOUL_FRENZY   = 'Rugf'
/**
@patch 1.00
*/
    constant integer UPG_FIEND_WEB      = 'Ruwb'
/**
@patch 1.00
*/
    constant integer UPG_ABOM           = 'Ruab'
/**
@patch 1.00
*/
    constant integer UPG_STONE_FORM     = 'Rusf'
/**
@patch 1.00
*/
    constant integer UPG_NECROS         = 'Rune'
/**
@patch 1.00
*/
    constant integer UPG_BANSHEE        = 'Ruba'
/**
@patch 1.00
*/
    constant integer UPG_MEAT_WAGON     = 'Rump'
/**
@patch 1.00
*/
    constant integer UPG_WYRM_BREATH    = 'Rufb'
/**
@patch 1.00
*/
    constant integer UPG_SKEL_LIFE      = 'Rusl'
/**
@patch 1.07
*/
    constant integer UPG_SKEL_MASTERY   = 'Rusm'
/**
@patch 1.07
*/
    constant integer UPG_EXHUME         = 'Ruex'
/**
@patch 1.00
*/
    constant integer UPG_SACRIFICE      = 'Rurs'
/**
@patch 1.00
*/
    constant integer UPG_ABOM_EXPL      = 'Ruax'
/**
@patch 1.00
*/
    constant integer UPG_CR_ARMOR       = 'Rucr'
/**
@patch 1.00
*/
    constant integer UPG_PLAGUE         = 'Rupc'
/**
@patch 1.07
*/
    constant integer UPG_BLK_SPHINX     = 'Rusp'
/**
@patch 1.07
*/
    constant integer UPG_BURROWING      = 'Rubu'

    //--------------------------------------------------------------------
    //  ELVES
    //--------------------------------------------------------------------

    // elf heroes
/**
@patch 1.00
*/
    constant integer DEMON_HUNTER       = 'Edem'
/**
@patch 1.00
*/
    constant integer DEMON_HUNTER_M     = 'Edmm'
/**
@patch 1.00
*/
    constant integer KEEPER             = 'Ekee'
/**
@patch 1.00
*/
    constant integer MOON_CHICK         = 'Emoo'
/**
@patch 1.00
*/
    constant integer MOON_BABE          =  MOON_CHICK
/**
@patch 1.00
*/
    constant integer MOON_HONEY         =  MOON_CHICK
/**
@patch 1.07
*/
    constant integer WARDEN             = 'Ewar'

    // special elf heroes
/**
@patch 1.00
*/
    constant integer SYLVANUS           = 'Hvwd'
/**
@patch 1.00
*/
    constant integer CENARIUS           = 'Ecen'
/**
@patch 1.07
*/
    constant integer ILLIDAN            = 'Eevi'
/**
@patch 1.07
*/
    constant integer ILLIDAN_DEMON      = 'Eevm'
/**
@patch 1.07
*/
    constant integer MAIEV              = 'Ewrd'

    // elf hero abilities
/**
@patch 1.00
*/
    constant integer FORCE_NATURE       = 'AEfn'
/**
@patch 1.00
*/
    constant integer ENT_ROOTS          = 'AEer'
/**
@patch 1.00
*/
    constant integer THORNS_AURA        = 'AEah'
/**
@patch 1.00
*/
    constant integer TRANQUILITY        = 'AEtq'

/**
@patch 1.00
*/
    constant integer EVASION            = 'AEev'
/**
@patch 1.00
*/
    constant integer IMMOLATION         = 'AEim'
/**
@patch 1.00
*/
    constant integer MANA_BURN          = 'AEmb'
/**
@patch 1.00
*/
    constant integer METAMORPHOSIS      = 'AEme'

/**
@patch 1.00
*/
    constant integer SEARING_ARROWS     = 'AHfa'
/**
@patch 1.00
*/
    constant integer SCOUT              = 'AEst'
/**
@patch 1.00
*/
    constant integer STARFALL           = 'AEsf'
/**
@patch 1.00
*/
    constant integer TRUESHOT           = 'AEar'

/**
@patch 1.07
*/
    constant integer BLINK              = 'AEbl'
/**
@patch 1.07
*/
    constant integer FAN_KNIVES         = 'AEfk'
/**
@patch 1.07
*/
    constant integer SHADOW_TOUCH       = 'AEsh'
/**
@patch 1.07
*/
    constant integer VENGEANCE          = 'AEsv'

    // elf units
/**
@patch 1.00
*/
    constant integer WISP               = 'ewsp'
/**
@patch 1.00
*/
    constant integer ARCHER             = 'earc'
/**
@patch 1.00
*/
    constant integer DRUID_TALON        = 'edot'
/**
@patch 1.00
*/
    constant integer DRUID_TALON_M      = 'edtm'
/**
@patch 1.00
*/
    constant integer BALLISTA           = 'ebal'
/**
@patch 1.00
*/
    constant integer DRUID_CLAW         = 'edoc'
/**
@patch 1.00
*/
    constant integer DRUID_CLAW_M       = 'edcm'
/**
@patch 1.00
*/
    constant integer DRYAD              = 'edry'
/**
@patch 1.00
*/
    constant integer HIPPO              = 'ehip'
/**
@patch 1.00
*/
    constant integer HIPPO_RIDER        = 'ehpr'
/**
@patch 1.00
*/
    constant integer HUNTRESS           = 'esen'
/**
@patch 1.00
*/
    constant integer CHIMAERA           = 'echm'
/**
@patch 1.00
*/
    constant integer ENT                = 'efon'
/**
@patch 1.07
*/
    constant integer MOUNTAIN_GIANT     = 'emtg'
/**
@patch 1.07
*/
    constant integer FAERIE_DRAGON      = 'efdr'

    // special elf units
/**
@patch 1.00
*/
    constant integer HIGH_ARCHER        = 'nhea'
/**
@patch 1.00
*/
    constant integer HIGH_FOOTMAN       = 'hcth'
/**
@patch 1.00
*/
    constant integer HIGH_FOOTMEN       =  HIGH_FOOTMAN
/**
@patch 1.00
*/
    constant integer HIGH_SWORDMAN      = 'hhes'
/**
@patch 1.00
*/
    constant integer DRAGON_HAWK        = 'nws1'
/**
@patch 1.00
*/
    constant integer CORRUPT_TREANT     = 'nenc'
/**
@patch 1.00
*/
    constant integer POISON_TREANT      = 'nenp'
/**
@patch 1.00
*/
    constant integer PLAGUE_TREANT      = 'nepl'
/**
@patch 1.00
*/
    constant integer SHANDRIS           = 'eshd'

    // elf buildings
/**
@patch 1.00
*/
    constant integer ANCIENT_LORE       = 'eaoe'
/**
@patch 1.00
*/
    constant integer ANCIENT_WAR        = 'eaom'
/**
@patch 1.00
*/
    constant integer ANCIENT_WIND       = 'eaow'
/**
@patch 1.00
*/
    constant integer TREE_AGES          = 'etoa'
/**
@patch 1.00
*/
    constant integer TREE_ETERNITY      = 'etoe'
/**
@patch 1.00
*/
    constant integer TREE_LIFE          = 'etol'
/**
@patch 1.00
*/
    constant integer ANCIENT_PROTECT    = 'etrp'
/**
@patch 1.00
*/
    constant integer ELF_ALTAR          = 'eate'
/**
@patch 1.00
*/
    constant integer BEAR_DEN           = 'edol'
/**
@patch 1.00
*/
    constant integer CHIMAERA_ROOST     = 'edos'
/**
@patch 1.00
*/
    constant integer HUNTERS_HALL       = 'edob'
/**
@patch 1.00
*/
    constant integer MOON_WELL          = 'emow'
/**
@patch 1.00
*/
    constant integer ELF_MINE           = 'egol'
/**
@patch 1.07
*/
    constant integer DEN_OF_WONDERS     = 'eden'

    // special elf buildings
/**
@patch 1.00
*/
    constant integer ELF_FARM           = 'nefm'
/**
@patch 1.00
*/
    constant integer ELF_GUARD_TOWER    = 'negt'
/**
@patch 1.00
*/
    constant integer HIGH_SKY           = 'negm'
/**
@patch 1.00
*/
    constant integer HIGH_EARTH         = 'negf'
/**
@patch 1.00
*/
    constant integer HIGH_TOWER         = 'negt'
/**
@patch 1.00
*/
    constant integer ELF_HIGH_BARRACKS  = 'nheb'
/**
@patch 1.00
*/
    constant integer CORRUPT_LIFE       = 'nctl'
/**
@patch 1.32.10.19202
*/
	constant integer CORRUPT_AGES       = 'ncta'
/**
@patch 1.32.10.19202
*/
	constant integer CORRUPT_ETERNITY   = 'ncte'
/**
@patch 1.00
*/
    constant integer CORRUPT_WELL       = 'ncmw'
/**
@patch 1.00
*/
    constant integer CORRUPT_PROTECTOR  = 'ncap'
/**
@patch 1.00
*/
    constant integer CORRUPT_WAR        = 'ncaw'

    // elf upgrades
/**
@patch 1.00
*/
    constant integer UPG_STR_MOON       = 'Resm'
/**
@patch 1.00
*/
    constant integer UPG_STR_WILD       = 'Resw'
/**
@patch 1.00
*/
    constant integer UPG_MOON_ARMOR     = 'Rema'
/**
@patch 1.00
*/
    constant integer UPG_HIDES          = 'Rerh'
/**
@patch 1.00
*/
    constant integer UPG_ULTRAVISION    = 'Reuv'
/**
@patch 1.00
*/
    constant integer UPG_BLESSING       = 'Renb'
/**
@patch 1.00
*/
    constant integer UPG_SCOUT          = 'Resc'
/**
@patch 1.00
*/
    constant integer UPG_GLAIVE         = 'Remg'
/**
@patch 1.00
*/
    constant integer UPG_BOWS           = 'Reib'
/**
@patch 1.00
*/
    constant integer UPG_MARKSMAN       = 'Remk'
/**
@patch 1.00
*/
    constant integer UPG_DRUID_TALON    = 'Redt'
/**
@patch 1.00
*/
    constant integer UPG_DRUID_CLAW     = 'Redc'
/**
@patch 1.00
*/
    constant integer UPG_ABOLISH        = 'Resi'
/**
@patch 1.00
*/
    constant integer UPG_CHIM_ACID      = 'Recb'
/**
@patch 1.00
*/
    constant integer UPG_HIPPO_TAME     = 'Reht'
/**
@patch 1.00
*/
    constant integer UPG_BOLT           = 'Repd'
/**
@patch 1.07
*/
    constant integer UPG_MARK_CLAW      = 'Reeb'
/**
@patch 1.07
*/
    constant integer UPG_MARK_TALON     = 'Reec'
/**
@patch 1.07
*/
    constant integer UPG_HARD_SKIN      = 'Rehs'
/**
@patch 1.07
*/
    constant integer UPG_RESIST_SKIN    = 'Rers'
/**
@patch 1.07
*/
    constant integer UPG_WELL_SPRING    = 'Rews'

    //--------------------------------------------------------------------
    // Neutral
    //--------------------------------------------------------------------
/**
@patch 1.00
*/
    constant integer DEMON_GATE         = 'ndmg'
/**
@patch 1.00
*/
    constant integer FELLHOUND          = 'nfel'
/**
@patch 1.00
*/
    constant integer INFERNAL           = 'ninf'
/**
@patch 1.00
*/
    constant integer DOOMGUARD          = 'nbal'
/**
@patch 1.00
*/
    constant integer SATYR              = 'nsty'
/**
@patch 1.00
*/
    constant integer TRICKSTER          = 'nsat'
/**
@patch 1.00
*/
    constant integer SHADOWDANCER       = 'nsts'
/**
@patch 1.00
*/
    constant integer SOULSTEALER        = 'nstl'
/**
@patch 1.00
*/
    constant integer HELLCALLER         = 'nsth'
/**
@patch 1.00
*/
    constant integer SKEL_ARCHER        = 'nska'
/**
@patch 1.00
*/
    constant integer SKEL_MARKSMAN      = 'nskm'
/**
@patch 1.00
*/
    constant integer SKEL_BURNING       = 'nskf'
/**
@patch 1.00
*/
    constant integer SKEL_GIANT         = 'nskg'
/**
@patch 1.00
*/
    constant integer FURBOLG            = 'nfrl'
/**
@patch 1.00
*/
    constant integer FURBOLG_TRACKER    = 'nfrb'
/**
@patch 1.00
*/
    constant integer FURBOLG_SHAMAN     = 'nfrs'
/**
@patch 1.00
*/
    constant integer FURBOLG_CHAMP      = 'nfrg'
/**
@patch 1.00
*/
    constant integer FURBOLG_ELDER      = 'nfre'

    //--------------------------------------------------------------------
    // NAGA
    //--------------------------------------------------------------------

    // naga heroes
/**
@patch 1.07
*/
    constant integer NAGA_SORCERESS     = 'Nngs'
/**
@patch 1.07
*/
    constant integer NAGA_VASHJ         = 'Hvsh'

    // naga units
/**
@patch 1.07
*/
    constant integer NAGA_DRAGON        = 'nsnp'        // old names
/**
@patch 1.07
*/
    constant integer NAGA_WITCH         = 'nnsw'
/**
@patch 1.07
*/
    constant integer NAGA_SERPENT       = 'nwgs'
/**
@patch 1.07
*/
    constant integer NAGA_HYDRA         = 'nhyc'

/**
@patch 1.07
*/
    constant integer NAGA_SLAVE         = 'nmpe'        // peon
/**
@patch 1.07
*/
    constant integer NAGA_SNAP_DRAGON   =  NAGA_DRAGON  // weak ranged
/**
@patch 1.07
*/
    constant integer NAGA_COUATL        =  NAGA_SERPENT // weak air
/**
@patch 1.07
*/
    constant integer NAGA_SIREN         =  NAGA_WITCH   // caster
/**
@patch 1.07
*/
    constant integer NAGA_MYRMIDON      = 'nmyr'        // knight
/**
@patch 1.07
*/
    constant integer NAGA_REAVER        = 'nnmg'        // footman
/**
@patch 1.07
*/
    constant integer NAGA_TURTLE        =  NAGA_HYDRA   // siege
/**
@patch 1.07
*/
    constant integer NAGA_ROYAL         = 'nnrg'        // royal guard

    // naga buildings
/**
@patch 1.07
*/
    constant integer NAGA_TEMPLE        = 'nntt'        // town hall
/**
@patch 1.07
*/
    constant integer NAGA_CORAL         = 'nnfm'        // farm
/**
@patch 1.07
*/
    constant integer NAGA_SHRINE        = 'nnsa'        // sirens & couatls
/**
@patch 1.07
*/
    constant integer NAGA_SPAWNING      = 'nnsg'        // myrm, snap dragon, hydra
/**
@patch 1.07
*/
    constant integer NAGA_GUARDIAN      = 'nntg'        // tower
/**
@patch 1.07
*/
    constant integer NAGA_ALTAR         = 'nnad'        // altar

    // naga upgrades
/**
@patch 1.07
*/
    constant integer UPG_NAGA_ARMOR     = 'Rnam'
/**
@patch 1.07
*/
    constant integer UPG_NAGA_ATTACK    = 'Rnat'
/**
@patch 1.07
*/
    constant integer UPG_NAGA_ABOLISH   = 'Rnsi'
/**
@patch 1.07
*/
    constant integer UPG_SIREN          = 'Rnsw'
/**
@patch 1.07
*/
    constant integer UPG_NAGA_ENSNARE   = 'Rnen'


    //--------------------------------------------------------------------
/**
@patch 1.00
*/
    constant integer M1                 =    60
/**
@patch 1.00
*/
    constant integer M2                 =  2*60
/**
@patch 1.00
*/
    constant integer M3                 =  3*60
/**
@patch 1.00
*/
    constant integer M4                 =  4*60
/**
@patch 1.00
*/
    constant integer M5                 =  5*60
/**
@patch 1.00
*/
    constant integer M6                 =  6*60
/**
@patch 1.00
*/
    constant integer M7                 =  7*60
/**
@patch 1.00
*/
    constant integer M8                 =  8*60
/**
@patch 1.00
*/
    constant integer M9                 =  9*60
/**
@patch 1.00
*/
    constant integer M10                = 10*60
/**
@patch 1.00
*/
    constant integer M11                = 11*60
/**
@patch 1.00
*/
    constant integer M12                = 12*60
/**
@patch 1.00
*/
    constant integer M13                = 13*60
/**
@patch 1.00
*/
    constant integer M14                = 14*60
/**
@patch 1.00
*/
    constant integer M15                = 15*60

/**
@patch 1.00
*/
    constant integer EASY               = 1
/**
@patch 1.00
*/
    constant integer NORMAL             = 2
/**
@patch 1.00
*/
    constant integer HARD               = 3
/**
@patch 1.00
*/
    constant integer INSANE             = 4 // not used

/**
@patch 1.03
*/
    constant integer MELEE_NEWBIE       = 1
/**
@patch 1.03
*/
    constant integer MELEE_NORMAL       = 2
/**
@patch 1.03
*/
    constant integer MELEE_INSANE       = 3

/**
@patch 1.00
*/
    constant integer ATTACK_CAPTAIN     = 1
/**
@patch 1.00
*/
    constant integer DEFENSE_CAPTAIN    = 2
/**
@patch 1.00
*/
    constant integer BOTH_CAPTAINS      = 3

/**
@patch 1.00
*/
    constant integer BUILD_UNIT         = 1
/**
@patch 1.00
*/
    constant integer BUILD_UPGRADE      = 2
/**
@patch 1.00
*/
    constant integer BUILD_EXPAND       = 3

/**
@patch 1.07
*/
    constant integer UPKEEP_TIER1       = 50
/**
@patch 1.07
*/
    constant integer UPKEEP_TIER2       = 80

    //--------------------------------------------------------------------

/**
@patch 1.00
*/
    player  ai_player

/**
@patch 1.00
*/
    integer sleep_seconds
/**
@patch 1.00
*/
    integer total_gold              = 0
/**
@patch 1.00
*/
    integer total_wood              = 0
/**
@patch 1.00
*/
    integer gold_buffer             = 0 // usually for potion money
/**
@patch 1.00
*/
    integer difficulty              = NORMAL
/**
@patch 1.07
*/
    integer exp_seen                = 0
/**
@patch 1.00
*/
    integer racial_farm             = 'hhou'
/**
@patch 1.00
*/
    integer hero_id                 = 'Hamg'
/**
@patch 1.00
*/
    integer hero_id2                = 'Hmkg'
/**
@patch 1.07
*/
    integer hero_id3                = 'Hpal'
/**
@patch 1.07
*/
    integer array skill
/**
@patch 1.00
*/
    integer array skills1
/**
@patch 1.00
*/
    integer array skills2
/**
@patch 1.07
*/
    integer array skills3
/**
@patch 1.00
*/
    integer max_hero_level          = 0

/**
@patch 1.00
*/
    integer array harass_qty
/**
@patch 1.00
*/
    integer array harass_max
/**
@patch 1.00
*/
    integer array harass_units
/**
@patch 1.00
*/
    integer harass_length           = 0

/**
@patch 1.00
*/
    integer array defense_qty
/**
@patch 1.00
*/
    integer array defense_units
/**
@patch 1.00
*/
    integer defense_length          = 0

/**
@patch 1.00
*/
    integer array build_qty
/**
@patch 1.00
*/
    integer array build_type
/**
@patch 1.00
*/
    integer array build_item
/**
@patch 1.00
*/
    integer array build_town
/**
@patch 1.00
*/
    integer build_length            = 0

/**
@patch 1.00
*/
    integer campaign_gold_peons     = 5
/**
@patch 1.00
*/
    integer campaign_wood_peons     = 3
/**
@patch 1.00
*/
    integer campaign_basics_speed   = 5

/**
@patch 1.07
*/
    integer min_creeps              = -1
/**
@patch 1.07
*/
    integer max_creeps              = -1

/**
@patch 1.00
*/
    boolean harvest_town1           = true
/**
@patch 1.00
*/
    boolean harvest_town2           = true
/**
@patch 1.00
*/
    boolean harvest_town3           = true
/**
@patch 1.00
*/
    boolean do_campaign_farms       = true
/**
@patch 1.00
*/
    boolean two_heroes              = false
/**
@patch 1.00
*/
    boolean allow_air_creeps        = false
/**
@patch 1.00
*/
    boolean take_exp                = false
/**
@patch 1.00
*/
    boolean allow_signal_abort      = false
/**
@patch 1.00
*/
    boolean ready_for_zeppelin      = true
/**
@patch 1.00
*/
    boolean get_zeppelin            = false

/**
@patch 1.00
*/
    boolean build_campaign_attackers = true

/**
@patch 1.00
*/
    boolean do_debug_cheats         = false
/**
@patch 1.00
*/
    boolean trace_on                = true
/**
@patch 1.07
*/
    boolean zep_next_wave           = false
/**
@patch 1.07
*/
    boolean form_group_timeouts     = true
endglobals

//============================================================================
/**
@patch 1.07
*/
function PlayerEx takes integer slot returns player
    return Player(slot-1)
endfunction

//============================================================================
/**
@patch 1.00
*/
function Trace takes string message returns nothing
    if trace_on then
        call DisplayText(GetAiPlayer(),message)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function TraceI takes string message, integer val returns nothing
    if trace_on then
        call DisplayTextI(GetAiPlayer(),message,val)
    endif
endfunction

//============================================================================
/**
@patch 1.07
*/
function TraceII takes string message, integer v1, integer v2 returns nothing
    if trace_on then
        call DisplayTextII(GetAiPlayer(),message,v1,v2)
    endif
endfunction

//============================================================================
/**
@patch 1.07
*/
function TraceIII takes string message, integer v1, integer v2, integer v3 returns nothing
    if trace_on then
        call DisplayTextIII(GetAiPlayer(),message,v1,v2,v3)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function InitAI takes nothing returns nothing
    set ai_player = Player(GetAiPlayer())
    set sleep_seconds = 0
    call StopGathering()
endfunction

//============================================================================
/**
@patch 1.00
*/
function StandardAI takes code heroes, code peons, code attacks returns nothing

    local boolean isNewbie = (MeleeDifficulty() == MELEE_NEWBIE)

    call InitAI()

    call SetMeleeAI()

    call SetDefendPlayer(true)
    call SetGroupsFlee(not isNewbie)
    call SetHeroesBuyItems(not isNewbie)
    call SetHeroesFlee(true)
    call SetHeroesTakeItems(true)
    call SetIgnoreInjured(true)
    call SetPeonsRepair(true)
    call SetSmartArtillery(not isNewbie)
    call SetTargetHeroes(not isNewbie)
    call SetUnitsFlee(not isNewbie)
    call SetWatchMegaTargets(true)

    call CreateCaptains()

    call SetHeroLevels(heroes)

    call Sleep(0.1)
    call StartThread(peons)
    call StartThread(attacks)
endfunction

//============================================================================
//  Utility Functions
//============================================================================
/**
@patch 1.07
*/
function Min takes integer A, integer B returns integer
    if A < B then
        return A
    else
        return B
    endif
endfunction

/**
@patch 1.07
*/
function Max takes integer A, integer B returns integer
    if A > B then
        return A
    else
        return B
    endif
endfunction

/**
@patch 1.07
*/
function SetZepNextWave takes nothing returns nothing
    set zep_next_wave = true
endfunction

/**
@patch 1.00
*/
function SuicideSleep takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds - seconds
    loop
        exitwhen seconds <= 0
        exitwhen allow_signal_abort and CommandsWaiting() != 0

        if seconds >= 5 then
            call Sleep(5)
            set seconds = seconds - 5
        else
            call Sleep(seconds)
            set seconds = 0
        endif
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function WaitForSignal takes nothing returns integer
    local integer cmd
    local boolean display = false //xxx
    loop
        exitwhen CommandsWaiting() != 0

        //xxx
        call Trace("waiting for a signal to begin AI script...\n")
        set display = true
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        exitwhen CommandsWaiting() != 0
        call Sleep(2)
        //xxx

    endloop

    //xxx
    if display then
        call Trace("signal received, beginning AI script\n")
    endif
    //xxx

    set cmd = GetLastCommand()
    call PopLastCommand()
    return cmd
endfunction

//============================================================================
/**
@patch 1.07
*/
function SetWoodPeons takes integer count returns nothing
    set campaign_wood_peons = count
endfunction

//============================================================================
/**
@patch 1.07
*/
function SetGoldPeons takes integer count returns nothing
    set campaign_gold_peons = count
endfunction

//============================================================================
/**
@patch 1.07
*/
function SetHarvestLumber takes boolean harvest returns nothing
    if harvest then
        set campaign_wood_peons = 3
    else
        set campaign_wood_peons = 0
    endif
endfunction

//============================================================================
/**
@patch 1.07
*/
function SetFormGroupTimeouts takes boolean state returns nothing
    set form_group_timeouts = state
endfunction

//============================================================================
/**
@patch 1.07
*/
function DoCampaignFarms takes boolean state returns nothing
    set do_campaign_farms = state
endfunction

//============================================================================
/**
@patch 1.00
*/
function GetMinorCreep takes nothing returns unit
    return GetCreepCamp(0,9,false)
endfunction

//============================================================================
/**
@patch 1.00
*/
function GetMajorCreep takes nothing returns unit
    return GetCreepCamp(10,100,allow_air_creeps)
endfunction

//============================================================================
/**
@patch 1.00
*/
function GetGold takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_GOLD)
endfunction

//============================================================================
/**
@patch 1.00
*/
function GetWood takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_LUMBER)
endfunction

//============================================================================
/**
@patch 1.00
*/
function InitBuildArray takes nothing returns nothing
    set build_length = 0
endfunction

//============================================================================
/**
@patch 1.00
*/
function InitAssaultGroup takes nothing returns nothing
    set harass_length = 0
endfunction

//============================================================================
/**
@patch 1.00
*/
function InitDefenseGroup takes nothing returns nothing
    set defense_length = 0
endfunction

//============================================================================
/**
@patch 1.00
*/
function InitMeleeGroup takes nothing returns nothing
    call InitAssaultGroup()
    call RemoveInjuries()
    call RemoveSiege()
endfunction

//============================================================================
/**
@patch 1.00
*/
function PrepFullSuicide takes nothing returns nothing
    call InitAssaultGroup()
    call InitDefenseGroup()
    set campaign_gold_peons = 0
    set campaign_wood_peons = 0
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetReplacements takes integer easy, integer med, integer hard returns nothing
    if difficulty == EASY then
        call SetReplacementCount(easy)
    elseif difficulty == NORMAL then
        call SetReplacementCount(med)
    else
        call SetReplacementCount(hard)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function StartTownBuilder takes code func returns nothing
    call StartThread(func)
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetBuildAll takes integer t, integer qty, integer unitid, integer town returns nothing
    if qty > 0 then
        set build_qty[build_length] = qty
        set build_type[build_length] = t
        set build_item[build_length] = unitid
        set build_town[build_length] = town
        set build_length = build_length + 1
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetBuildUnit takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,-1)
endfunction

//============================================================================
/**
@patch 1.07
*/
function SetBuildNext takes integer qty, integer unitid returns nothing
    local integer has = GetUnitCount(unitid)
    if has >= qty then
        return
    endif
    call SetBuildAll(BUILD_UNIT,GetUnitCountDone(unitid)+1,unitid,-1)
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetBuildUnitEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UNIT,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UNIT,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UNIT,hard,unitid,-1)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function SecondaryTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

//============================================================================
/**
@patch 1.00
*/
function SecTown takes integer town, integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_UNIT,qty,unitid,town)
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetBuildUpgr takes integer qty, integer unitid returns nothing
    if MeleeDifficulty() != MELEE_NEWBIE or qty == 1 then
        call SetBuildAll(BUILD_UPGRADE,qty,unitid,-1)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetBuildUpgrEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SetBuildAll(BUILD_UPGRADE,easy,unitid,-1)
    elseif difficulty == NORMAL then
        call SetBuildAll(BUILD_UPGRADE,med,unitid,-1)
    else
        call SetBuildAll(BUILD_UPGRADE,hard,unitid,-1)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetBuildExpa takes integer qty, integer unitid returns nothing
    call SetBuildAll(BUILD_EXPAND,qty,unitid,-1)
endfunction

//============================================================================
/**
@patch 1.00
*/
function StartUpgrade takes integer level, integer upgid returns boolean
    local integer gold_cost
    local integer wood_cost

    if GetUpgradeLevel(upgid) >= level then
        return true
    endif

    set gold_cost = GetUpgradeGoldCost(upgid)
    if total_gold < gold_cost then
        return false
    endif

    set wood_cost = GetUpgradeWoodCost(upgid)
    if total_wood < wood_cost then
        return false
    endif

    return SetUpgrade(upgid)
endfunction

//============================================================================
/**
@patch 1.00
*/
function BuildFactory takes integer unitid returns nothing
    if GetGold() > 1000 and GetWood() > 500 then
        call SetBuildUnit( 2, unitid )
    else
        call SetBuildUnit( 1, unitid )
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function HallsCompleted takes integer unitid returns boolean
    return GetUnitCount(unitid) == GetUnitCountDone(unitid)
endfunction

//============================================================================
/**
@patch 1.00
*/
function GuardSecondary takes integer townid, integer qty, integer unitid returns nothing
    if TownHasHall(townid) and TownHasMine(townid) then
        call SecondaryTown( townid, qty, unitid )
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function GetUnitCountEx takes integer unitid, boolean only_done, integer townid returns integer
    if townid == -1 then
        if only_done then
            return GetUnitCountDone(unitid)
        else
            return GetUnitCount(unitid)
        endif
    else
        return GetTownUnitCount(unitid,townid,only_done)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function TownCountEx takes integer unitid, boolean only_done, integer townid returns integer

    local integer have_qty = GetUnitCountEx(unitid,only_done,townid)

    if unitid == TOWN_HALL then
        set have_qty = have_qty + GetUnitCountEx(KEEP,false,townid) + GetUnitCountEx(CASTLE,false,townid)
    elseif unitid == KEEP then
        set have_qty = have_qty  + GetUnitCountEx(CASTLE,false,townid)

    elseif unitid == WATCH_TOWER then
        set have_qty = have_qty + GetUnitCountEx(GUARD_TOWER,false,townid) + GetUnitCountEx(CANNON_TOWER,false,townid) + GetUnitCountEx(ARCANE_TOWER,false,townid)

    elseif unitid == PEASANT then
        set have_qty = have_qty + GetUnitCountEx(MILITIA,false,townid)

    elseif unitid == GREAT_HALL then
        set have_qty = have_qty + GetUnitCountEx(STRONGHOLD,false,townid) + GetUnitCountEx(FORTRESS,false,townid)
    elseif unitid == STRONGHOLD then
        set have_qty = have_qty + GetUnitCountEx(FORTRESS,false,townid)

    elseif unitid == HEAD_HUNTER then
        set have_qty = have_qty + GetUnitCountEx(BERSERKER,false,townid)

    elseif unitid == SPIRIT_WALKER then
        set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER_M,false,townid)
    elseif unitid == SPIRIT_WALKER_M then
        set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER,only_done,townid)

    elseif unitid == NECROPOLIS_1 then
        set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_2,false,townid) + GetUnitCountEx(NECROPOLIS_3,false,townid)
    elseif unitid == NECROPOLIS_2 then
        set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_3,false,townid)

    elseif unitid == ZIGGURAT_1 then
        set have_qty = have_qty + GetUnitCountEx(ZIGGURAT_2,false,townid) + GetUnitCountEx(ZIGGURAT_FROST,false,townid)

    elseif unitid == GARGOYLE then
        set have_qty = have_qty + GetUnitCountEx(GARGOYLE_MORPH,false,townid)

    elseif unitid == TREE_LIFE then
        set have_qty = have_qty + GetUnitCountEx(TREE_AGES,false,townid) + GetUnitCountEx(TREE_ETERNITY,false,townid)
    elseif unitid == TREE_AGES then
        set have_qty = have_qty + GetUnitCountEx(TREE_ETERNITY,false,townid)

    elseif unitid == DRUID_TALON then
        set have_qty = have_qty + GetUnitCountEx(DRUID_TALON_M,false,townid)
    elseif unitid == DRUID_TALON_M then
        set have_qty = have_qty + GetUnitCountEx(DRUID_TALON,only_done,townid)

    elseif unitid == DRUID_CLAW then
        set have_qty = have_qty + GetUnitCountEx(DRUID_CLAW_M,false,townid)
    elseif unitid == DRUID_CLAW_M then
        set have_qty = have_qty + GetUnitCountEx(DRUID_CLAW,only_done,townid)

    elseif unitid == ILLIDAN then
        set have_qty = have_qty + GetUnitCountEx(ILLIDAN_DEMON,false,townid)

    endif
    return have_qty
endfunction

//============================================================================
/**
@patch 1.00
*/
function TownCountDone takes integer base returns integer
    return TownCountEx(base,true,-1)
endfunction

//============================================================================
/**
@patch 1.00
*/
function TownCount takes integer base returns integer
    return TownCountEx(base,false,-1)
endfunction

//============================================================================
/**
@patch 1.00
*/
function BasicExpansion takes boolean build_it, integer unitid returns nothing
    if build_it and HallsCompleted(unitid) then
        call SetBuildExpa( TownCount(unitid)+1, unitid )
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function UpgradeAll takes integer baseid, integer newid returns nothing
    call SetBuildUnit( TownCountDone(baseid), newid )
endfunction

//============================================================================
/**
@patch 1.00
*/
function TownCountTown takes integer base, integer townid returns integer
    return TownCountEx(base,false,townid)
endfunction

//============================================================================
//  FoodPool
//============================================================================
/**
@patch 1.00
*/
function FoodPool takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2 returns nothing
    if strong then
        call SetBuildUnit( (food - use1 * TownCount(id1)) / use2, id2 )
    elseif weak then
        call SetBuildUnit( (food - use2 * TownCount(id2)) / use1, id1 )
    endif
endfunction

//============================================================================
//  MeleeTownHall
//============================================================================
/**
@patch 1.00
*/
function MeleeTownHall takes integer townid, integer unitid returns nothing
    if TownHasMine(townid) and not TownHasHall(townid) then
        call SecondaryTown ( townid, 1, unitid )
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function WaitForUnits takes integer unitid, integer qty returns nothing
    loop
        exitwhen TownCountDone(unitid) == qty
        call Sleep(2)
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function StartUnit takes integer ask_qty, integer unitid, integer town returns boolean
    local integer have_qty
    local integer need_qty
    local integer afford_gold
    local integer afford_wood
    local integer afford_qty
    local integer gold_cost
    local integer wood_cost

    //------------------------------------------------------------------------
    // if we have all we're asking for then make nothing
    //
    if town == -1 then
        set have_qty = TownCount(unitid)
    else
        set have_qty = TownCountTown(unitid,town)
    endif

    if have_qty >= ask_qty then
        return true
    endif
    set need_qty = ask_qty - have_qty

    //------------------------------------------------------------------------
    // limit the qty we're requesting to the amount of resources available
    //
    set gold_cost = GetUnitGoldCost(unitid)
    set wood_cost = GetUnitWoodCost(unitid)

    if gold_cost == 0 then
        set afford_gold = need_qty
    else
        set afford_gold = total_gold / gold_cost
    endif
    if afford_gold < need_qty then
        set afford_qty = afford_gold
    else
        set afford_qty = need_qty
    endif

    if wood_cost == 0 then
        set afford_wood = need_qty
    else
        set afford_wood = total_wood / wood_cost
    endif
    if afford_wood < afford_qty then
        set afford_qty = afford_wood
    endif

    // if we're waiting on gold/wood; pause build orders
    if afford_qty < 1 then
        return false
    endif

    //------------------------------------------------------------------------
    // whether we make right now what we're requesting or not, assume we will
    // and deduct the cost of the units from our fake gold total right away
    //
    set total_gold = total_gold - gold_cost * need_qty
    set total_wood = total_wood - wood_cost * need_qty

    if total_gold < 0 then
        set total_gold = 0
    endif
    if total_wood < 0 then
        set total_wood = 0
    endif

    //------------------------------------------------------------------------
    // give the AI a chance to make the units (it may not be able to right now
    // but that doesn't stop us from trying other units after this as long
    // as we have enough money to make this AND the needed, unbuilt ones)
    //
    return SetProduce(afford_qty,unitid,town)
endfunction

//============================================================================
/**
@note If `exitwhen i == 12` represents a player ID, then it buggy when run in 24-player mode.
@patch 1.00
*/
function WaitForTown takes integer towns, integer townid returns nothing
    local integer i = 0
    loop
        call Sleep(10)
        exitwhen TownCount(townid) >= towns
        set i = i + 1
        exitwhen i == 12
    endloop
endfunction

//============================================================================
/**
@bug Leaks handle `peon`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function StartExpansion takes integer qty, integer hall returns boolean
    local integer count
    local integer town
    local unit    peon
    local integer gold_cost

    set count = TownCount(hall)
    if count >= qty then
        return true
    endif

    set town = GetNextExpansion()
    if town == -1 then
        return true
    endif

    set take_exp = true

    set gold_cost = GetUnitGoldCost(hall)
    if gold_cost > total_gold then
        return false
    endif
    set total_gold = total_gold - gold_cost

    if GetExpansionFoe() != null then
        return true
    endif

    set peon = GetExpansionPeon()
    if peon != null then
        return SetExpansion(peon,hall)
    endif

    return true
endfunction

//============================================================================
/**
@patch 1.00
*/
function OneBuildLoop takes nothing returns nothing
    local integer index = 0
    local integer qty
    local integer id
    local integer tp

    set total_gold = GetGold() - gold_buffer
    set total_wood = GetWood()

    loop
        exitwhen index == build_length

        set qty = build_qty [index]
        set id  = build_item[index]
        set tp  = build_type[index]

        //--------------------------------------------------------------------
        if tp == BUILD_UNIT then
            if not StartUnit(qty,id,build_town[index]) then
                return
            endif

        //--------------------------------------------------------------------
        elseif tp == BUILD_UPGRADE then
            call StartUpgrade(qty,id)

        //--------------------------------------------------------------------
        else // tp == BUILD_EXPAND
            if not StartExpansion(qty,id) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function StaggerSleep takes real base, real spread returns nothing
    call Sleep(base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers()))
endfunction

//============================================================================
/**
@patch 1.00
*/
function BuildLoop takes nothing returns nothing
    call OneBuildLoop()
    call StaggerSleep(1,2)
    loop
        call OneBuildLoop()
        call Sleep(2)
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function StartBuildLoop takes nothing returns nothing
    call StartThread(function BuildLoop)
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetInitialWave takes integer seconds returns nothing
    set sleep_seconds = seconds
endfunction

//============================================================================
/**
@patch 1.00
*/
function AddSleepSeconds takes integer seconds returns nothing
    set sleep_seconds = sleep_seconds + seconds
endfunction

//============================================================================
/**
@patch 1.00
*/
function SleepForever takes nothing returns nothing
    call Trace("going to sleep forever\n") //xxx
    loop
        call Sleep(100)
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function PlayGame takes nothing returns nothing
    call StartBuildLoop()
    call SleepForever()
endfunction

//============================================================================
/**
@patch 1.07
*/
function ConvertNeeds takes integer unitid returns nothing
    if GetUnitCount(unitid) < 1 then
        call StartUnit(1,unitid,-1)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function Conversions takes integer desire, integer unitid returns nothing

    if GetUnitCount(unitid) >= desire then
        return
    endif

    if unitid == HIPPO_RIDER then
        call ConvertNeeds(ARCHER)
        call ConvertNeeds(HIPPO)
        call MergeUnits(desire,ARCHER,HIPPO,HIPPO_RIDER)

    elseif unitid == BLK_SPHINX then
        call ConvertNeeds(OBS_STATUE)
        call ConvertUnits(desire,OBS_STATUE)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetAssaultGroup takes integer qty, integer max, integer unitid returns nothing
    call Conversions(max,unitid)

    if qty <= 0 and TownCountDone(unitid) == 0 then
        return
    endif
    set harass_qty[harass_length] = qty
    set harass_max[harass_length] = max
    set harass_units[harass_length] = unitid
    set harass_length = harass_length + 1
endfunction

//============================================================================
/**
@patch 1.00
*/
function Interleave3 takes integer e1, integer m1, integer h1, integer u1, integer e2, integer m2, integer h2, integer u2, integer e3, integer m3, integer h3, integer u3 returns nothing
    local integer i1 = 1
    local integer i2 = 1
    local integer i3 = 1
    local integer q1
    local integer q2
    local integer q3

    if difficulty == EASY then
        set q1 = e1
        set q2 = e2
        set q3 = e3
    elseif difficulty == NORMAL then
        set q1 = m1
        set q2 = m2
        set q3 = m3
    else // difficulty == HARD
        set q1 = h1
        set q2 = h2
        set q3 = h3
    endif

    loop
        exitwhen q1<=0 and q2<=0 and q3<=0

        if q1 > 0 then
            call SetAssaultGroup(i1,i1,u1)
            set q1 = q1 - 1
            set i1 = i1 + 1
        endif

        if q2 > 0 then
            call SetAssaultGroup(i2,i2,u2)
            set q2 = q2 - 1
            set i2 = i2 + 1
        endif

        if q3 > 0 then
            call SetAssaultGroup(i3,i3,u3)
            set q3 = q3 - 1
            set i3 = i3 + 1
        endif
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function SetMeleeGroup takes integer unitid returns nothing
    if unitid == hero_id then
        call SetAssaultGroup(1,9,unitid)
    else
        call SetAssaultGroup((TownCountDone(unitid)*3)/4,20,unitid)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignDefender takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then
        set defense_qty[defense_length] = qty
        set defense_units[defense_length] = unitid
        set defense_length = defense_length + 1
        call Conversions(qty,unitid)
        call SetBuildUnit(qty,unitid)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignDefenderEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignDefender(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignDefender(NORMAL,med,unitid)
    else
        call CampaignDefender(HARD,hard,unitid)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignAttacker takes integer level, integer qty, integer unitid returns nothing
    if qty > 0 and difficulty >= level then
        call SetAssaultGroup(qty,qty,unitid)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignAttackerEx takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call CampaignAttacker(EASY,easy,unitid)
    elseif difficulty == NORMAL then
        call CampaignAttacker(NORMAL,med,unitid)
    else
        call CampaignAttacker(HARD,hard,unitid)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function FormGroup takes integer seconds, boolean testReady returns nothing
    local integer index
    local integer count
    local integer unitid
    local integer desire
    local integer readyPercent

    // normally test for CaptainReadiness() of 50%
    if testReady == true then
        set readyPercent = 50
        call Trace("forming group, requiring healthy guys\n") //xxx
    else
        set readyPercent = 0
        call Trace("forming group, unit health not important\n") //xxx
    endif

    call Trace("trying to gather forces\n") //xxx

    loop
        call SuicideSleep(seconds)
        call InitAssault()

        set index = 0
        loop
            exitwhen index == harass_length

            set unitid = harass_units[index]
            set desire = harass_max[index]
            set count  = TownCountDone(unitid)

            call Conversions(desire,unitid)

            if count >= desire then
                call AddAssault(desire,unitid)
            else
                set desire = harass_qty[index]

                if count < desire then
                    call AddAssault(desire,unitid)
                else
                    call AddAssault(count,unitid)
                endif
            endif

            set index = index + 1
        endloop

        //xxx
        if form_group_timeouts and (sleep_seconds < -60) then
            call Trace("exit form group -- timeout\n")
        elseif CaptainInCombat(true) then
            call Trace("exit form group -- can't form while already in combat\n")
        elseif CaptainIsFull() and CaptainReadiness() >= readyPercent then
            call Trace("exit form group -- ready\n")
        endif
        //xxx

        // time out and send group anyway if time has already expired
        exitwhen form_group_timeouts and (sleep_seconds < -60)
        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsFull() and CaptainReadiness() >= readyPercent
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function WavePrepare takes integer unitid returns integer
    return GetUnitBuildTime(unitid)
endfunction

//============================================================================
/**
@patch 1.00
*/
function PrepTime takes nothing returns integer
    local integer unitid
    local integer missing
    local integer prep
    local integer count
    local integer largest = 30
    local integer index = 0

    loop
        exitwhen index == harass_length

        set unitid  = harass_units[index]
        set missing = harass_qty[index] + IgnoredUnits(unitid) - TownCount(unitid)
        set prep    = WavePrepare(unitid) * missing

        if prep > largest then
            set largest = prep
        endif

        set index = index + 1
    endloop
    call TraceI("next wave will require around %d seconds to build and gather\n",largest) //xxx

    return largest
endfunction

//============================================================================
/**
@patch 1.07
*/
function PrepSuicideOnPlayer takes integer seconds returns boolean
    local integer wave_prep   = PrepTime()
    local integer save_length

    set save_length = harass_length
    set harass_length = 0

    call AddSleepSeconds(seconds)
    if sleep_seconds-wave_prep > 0 then
        call TraceI("going to sleep for %d seconds before gathering next attack wave\n",sleep_seconds-wave_prep) //xxx
        call SuicideSleep(sleep_seconds-wave_prep)
    endif

    call Trace("preparing suicide attack wave\n") //xxx

    set harass_length = save_length
    if harass_length < 1 then
        call Trace("ERROR - no units specificed, exiting early\n") //xxx
        return false
    endif

    return true
endfunction

//============================================================================
/**
@patch 1.00
*/
function SleepUntilAtGoal takes nothing returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainAtGoal()        // reached goal
        exitwhen CaptainIsHome()        // failed to path and returned home
        exitwhen CaptainIsEmpty()       // all units died
        call SuicideSleep(3)
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function SleepInCombat takes nothing returns nothing
    local integer count = 0
    debug call Trace("SleepInCombat\n")
    loop
        loop
            exitwhen not CaptainInCombat(true)  // goal is cleared
            exitwhen CaptainIsEmpty()           // duh
            call SuicideSleep(1)
        endloop

        set count = count + 1
        exitwhen count >= 8

        //xxx this is what it should have been; do this for next patch?
        //call SuicideSleep(1)
    endloop
    debug call Trace("exit SleepInCombat\n")
endfunction

//============================================================================
/**
@patch 1.00
*/
function AttackMoveXYA takes integer x, integer y returns nothing

    if zep_next_wave then
        call LoadZepWave(x,y)
        set zep_next_wave = false
    endif

    call AttackMoveXY(x,y)
    call SleepUntilAtGoal()
    call SleepInCombat()
endfunction

//============================================================================
/**
@patch 1.07
*/
function SuicideOnPlayerWave takes nothing returns nothing
    call Trace("waiting for attack wave to enter combat\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif

        if CaptainInCombat(true) then
            call Trace("done - captain has entered combat\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainInCombat(true)
        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop

    call Trace("waiting for attack wave to die\n") //xxx
    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT - attack wave override\n")
        endif

        if CaptainIsEmpty() then
            call Trace("done - all units are dead\n")
        endif

        if sleep_seconds < -300 then
            call Trace("done - timeout, took too long to reach engage the enemy\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        exitwhen CaptainIsEmpty()
        call SuicideSleep(10)
        exitwhen sleep_seconds < -300
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function CommonSuicideOnPlayer takes boolean standard, boolean bldgs, integer seconds, player p, integer x, integer y returns nothing
    local integer save_peons

    if not PrepSuicideOnPlayer(seconds) then
        return
    endif

    set save_peons = campaign_wood_peons
    set campaign_wood_peons = 0

    loop
        //xxx
        if allow_signal_abort and CommandsWaiting() != 0 then
            call Trace("ABORT -- attack wave override\n")
        endif
        //xxx

        exitwhen allow_signal_abort and CommandsWaiting() != 0

        loop
            exitwhen allow_signal_abort and CommandsWaiting() != 0

            call FormGroup(5,true)
            exitwhen sleep_seconds <= 0
            call TraceI("waiting %d seconds before suicide\n",sleep_seconds) //xxx
        endloop

        if standard then
            if bldgs then
                exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            else
                exitwhen SuicidePlayerUnits(p,sleep_seconds >= -60)
            endif
        else
            call AttackMoveXYA(x,y)
        endif

        call TraceI("waiting %d seconds before timeout\n",60+sleep_seconds) //xxx
        call SuicideSleep(5)
    endloop

    set campaign_wood_peons = save_peons
    set harass_length = 0

    call SuicideOnPlayerWave()
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.00
*/
function SuicideOnPlayer takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,true,seconds,p,0,0)
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideOnUnits takes integer seconds, player p returns nothing
    call CommonSuicideOnPlayer(true,false,seconds,p,0,0)
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideOnPoint takes integer seconds, player p, integer x, integer y returns nothing
    call CommonSuicideOnPlayer(false,false,seconds,p,x,y)
endfunction

//============================================================================
/**
@patch 1.00
*/
function SuicideUntilSignal takes integer seconds, player p returns nothing
    local integer save
    local integer wave_prep = PrepTime()

    loop
        call AddSleepSeconds(seconds)
        if sleep_seconds-wave_prep > 0 then
            call SuicideSleep(sleep_seconds-wave_prep)
        endif

        set save = campaign_wood_peons
        set campaign_wood_peons = 0
        loop
            loop
                call FormGroup(5, true)
                exitwhen sleep_seconds <= 0
                exitwhen CommandsWaiting() != 0
            endloop
            exitwhen SuicidePlayer(p,sleep_seconds >= -60)
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(3)
        endloop
        set campaign_wood_peons = save

        loop
            exitwhen CaptainIsEmpty()
            exitwhen CommandsWaiting() != 0
            call SuicideSleep(5)
        endloop
        exitwhen CommandsWaiting() != 0
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideOnce takes integer easy, integer med, integer hard, integer unitid returns nothing
    if difficulty == EASY then
        call SuicideUnit(easy,unitid)
    elseif difficulty == NORMAL then
        call SuicideUnit(med,unitid)
    else
        call SuicideUnit(hard,unitid)
    endif
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.00
*/
function SuicideUnitA takes integer unitid returns nothing
    if unitid != 0 then
        call SuicideUnit(1,unitid)
    endif
    call Sleep(0.1)
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideUnitB takes integer unitid, integer playerid returns nothing
    if unitid != 0 then
        call SuicideUnitEx(1,unitid,playerid)
    endif
    call Sleep(0.1)
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.00
*/
function SuicideUnits takes integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitA(u1)
        call SuicideUnitA(u2)
        call SuicideUnitA(u3)
        call SuicideUnitA(u4)
        call SuicideUnitA(u5)
        call SuicideUnitA(u6)
        call SuicideUnitA(u7)
        call SuicideUnitA(u8)
        call SuicideUnitA(u9)
        call SuicideUnitA(uA)
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideUnitsEx takes integer playerid, integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
    call Trace("MASS SUICIDE - this script is now technically done\n") //xxx

    call PrepFullSuicide()
    loop
        call SuicideUnitB(u1,playerid)
        call SuicideUnitB(u2,playerid)
        call SuicideUnitB(u3,playerid)
        call SuicideUnitB(u4,playerid)
        call SuicideUnitB(u5,playerid)
        call SuicideUnitB(u6,playerid)
        call SuicideUnitB(u7,playerid)
        call SuicideUnitB(u8,playerid)
        call SuicideUnitB(u9,playerid)
        call SuicideUnitB(uA,playerid)
    endloop
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.00
*/
function SuicideOnPlayerEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnPlayer(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnPlayer(med,p)
    else
        call SuicideOnPlayer(hard,p)
    endif
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideOnUnitsEx takes integer easy, integer med, integer hard, player p returns nothing
    if difficulty == EASY then
        call SuicideOnUnits(easy,p)
    elseif difficulty == NORMAL then
        call SuicideOnUnits(med,p)
    else
        call SuicideOnUnits(hard,p)
    endif
endfunction

//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SuicideOnPointEx takes integer easy, integer med, integer hard, player p, integer x, integer y returns nothing
    if difficulty == EASY then
        call SuicideOnPoint(easy,p,x,y)
    elseif difficulty == NORMAL then
        call SuicideOnPoint(med,p,x,y)
    else
        call SuicideOnPoint(hard,p,x,y)
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function ForeverSuicideOnPlayer takes integer seconds, player p returns nothing
    local integer length = harass_length
    loop
        exitwhen allow_signal_abort and CommandsWaiting() != 0
        call SuicideOnPlayer(seconds,p)
        set harass_length = length
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function CommonSleepUntilTargetDead takes unit target, boolean reform returns nothing
    loop
        exitwhen CaptainRetreating()
        exitwhen CaptainReadinessHP() <= 40

        exitwhen not UnitAlive(target)
        exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)

        if not TownThreatened() then
            call AttackMoveKill(target)
        endif

        call SuicideSleep(3)

        if reform and sleep_seconds < -40 then
            if CaptainInCombat(true) then
                set sleep_seconds = sleep_seconds + 5
            else
                set sleep_seconds = 0
                call FormGroup(1,false)
            endif
        endif
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function SleepUntilTargetDead takes unit target returns nothing
    call CommonSleepUntilTargetDead(target,false)
endfunction

//============================================================================
/**
@patch 1.00
*/
function ReformUntilTargetDead takes unit target returns nothing
    debug call Trace("ReformUntilTargetDead\n")
    call CommonSleepUntilTargetDead(target,true)
endfunction

//============================================================================
/**
@patch 1.00
*/
function AttackMoveKillA takes unit target returns nothing
    if target == null then
        call SuicideSleep(3)
        return
    endif

    debug call Trace("AttackMoveKillA\n")
    call AttackMoveKill(target)
    call ReformUntilTargetDead(target)
    call SleepInCombat()
endfunction

//============================================================================
/**
@bug Leaks handle `target`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function MinorCreepAttack takes nothing returns nothing
    local unit target = GetMinorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3, true)
    call AttackMoveKillA(target)
endfunction

//============================================================================
/**
@bug Leaks handle `target`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function MajorCreepAttack takes nothing returns nothing
    local unit target = GetMajorCreep()
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
endfunction

//============================================================================
/**
@bug Leaks handle `target`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.07
*/
function CreepAttackEx takes nothing returns nothing
    local unit target = GetCreepCamp(min_creeps,max_creeps,allow_air_creeps)
    call SetAllianceTarget(target)
    call FormGroup(3,true)
    call AttackMoveKillA(target)
endfunction

//============================================================================
/**
@bug Leaks handle `hall`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function AnyPlayerAttack takes nothing returns nothing
    local unit hall

    set hall = GetEnemyExpansion()
    if hall == null then
        call StartGetEnemyBase()
        loop
            exitwhen not WaitGetEnemyBase()
            call SuicideSleep(1)
        endloop
        set hall = GetEnemyBase()
    endif

    call SetAllianceTarget(hall)
    call FormGroup(3,true)
    call AttackMoveKillA(hall)
endfunction

//============================================================================
/**
@bug Leaks handle `creep`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function ExpansionAttack takes nothing returns nothing
    local unit creep = GetExpansionFoe()
    local integer x

    call FormGroup(3, true)
    if creep == null then
        set x = GetExpansionX()
        if x != -1 then
            call AttackMoveXYA(x,GetExpansionY())
        endif
    else
        call AttackMoveKillA(creep)
    endif
endfunction

//============================================================================
//  AddSiege
//============================================================================
/**
@patch 1.00
*/
function AddSiege takes nothing returns nothing
    call SetAssaultGroup( 0, 9, SHADE       )
    call SetAssaultGroup( 0, 9, MEAT_WAGON  )
    call SetAssaultGroup( 0, 9, MORTAR      )
    call SetAssaultGroup( 0, 9, TANK        )
    call SetAssaultGroup( 0, 9, BALLISTA    )
    call SetAssaultGroup( 0, 9, CATAPULT    )
endfunction

//===========================================================================
//  GetAllyCount
//============================================================================
/**
@bug Not compatible with 24-player mode.
@patch 1.07
*/
function GetAllyCount takes player whichPlayer returns integer
    local integer    playerIndex = 0
    local integer    count = 0
    local player     indexPlayer

    loop
        set indexPlayer = Player(playerIndex)

        if whichPlayer != indexPlayer then
            if GetPlayerAlliance(whichPlayer,indexPlayer,ALLIANCE_PASSIVE) then
                if GetPlayerAlliance(indexPlayer,whichPlayer,ALLIANCE_PASSIVE) then
                    if GetPlayerStructureCount(indexPlayer,true) > 0 then
                        set count = count + 1
                    endif
                endif
            endif
        endif

        set playerIndex = playerIndex + 1
        exitwhen playerIndex == 12
    endloop

    return count
endfunction

//============================================================================
//  SingleMeleeAttack
//============================================================================
/**
@bug Leaks handle:

1. hall
2. mega
3. creep
4. common

In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function SingleMeleeAttack takes boolean needs_exp, boolean has_siege, boolean major_ok, boolean air_units returns nothing
    local boolean   can_siege
    local real      daytime
    local unit      hall
    local unit      mega
    local unit      creep
    local unit      common
    local integer   minimum
    local boolean   allies

    call Trace("===SingleMeleeAttack===\n") //xxx

    if TownThreatened() then
        call Trace("sleep 2, town threatened\n") //xxx
        call Sleep(2)
        return
    endif

    // purchase zeppelins
    //
    if get_zeppelin and GetGold() > 300 and GetWood() > 100 then
        call Trace("purchase zep\n") //xxx
        call PurchaseZeppelin()
        set get_zeppelin = false
        set ready_for_zeppelin = false
        return
    endif
    set ready_for_zeppelin = true

    // coordinate with allies
    //
    set allies = GetAllyCount(ai_player) > 0
    if allies and MeleeDifficulty() != MELEE_NEWBIE then
        set common = GetAllianceTarget()
        if common != null then
            call Trace("join ally force\n") //xxx
            if GetMegaTarget() != null then
                call AddSiege()
            endif
            call FormGroup(3,true)
            call AttackMoveKillA(common)
            call SetAllianceTarget(null)
            return
        endif
    endif

    // take expansions as needed
    //
    if needs_exp then
        call Trace("needs exp\n") //xxx
        set creep = GetExpansionFoe()
        if creep != null then
            call Trace("attack exp\n") //xxx
            call SetAllianceTarget(creep)
            call FormGroup(3,true)
            call AttackMoveKillA(creep)
            call Sleep(20)
            set take_exp = false
            return
        endif
    endif

    // all-out attack if the player is weak
    //
    if MeleeDifficulty() != MELEE_NEWBIE then
        set mega = GetMegaTarget()
        if mega != null then
            call Trace("MEGA TARGET!!!\n") //xxx
            call AddSiege()
            call FormGroup(3,true)
            call AttackMoveKillA(mega)
            return
        endif
    endif

    // deny player an expansion
    //
    set hall = GetEnemyExpansion()
    set daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
    set can_siege = has_siege and (air_units or (daytime>=4 and daytime<=12))

    if hall!=null and (can_siege or not IsTowered(hall)) then

        call Trace("test player town attack\n") //xxx

        if MeleeDifficulty() == MELEE_NEWBIE then
            set minimum = 3
        elseif allies and MeleeDifficulty() == MELEE_NORMAL then
            set minimum = 1
        else
            set minimum = 0 // HARD, INSANE, and NORMAL with no allies
        endif

        if exp_seen >= minimum then
            call Trace("do player town attack\n") //xxx
            set exp_seen = 0
            call AddSiege()
            call SetAllianceTarget(hall)
            call FormGroup(3,true)
            call AttackMoveKillA(hall)
            return
        endif

        set exp_seen = exp_seen + 1
    endif

    // attack player's main base when siege is available
    //
    if can_siege then
        call Trace("attack player's town\n") //xxx
        call AddSiege()
        call AnyPlayerAttack()
        return
    endif

    // extended, more specific method of determining creep levels
    //
    if min_creeps != -1 then
        call TraceI("custom creep attack %d\n",max_creeps) //xxx
        call CreepAttackEx()
        return
    endif

    // nothing better to do, so kill a creep camp
    //
    if major_ok then
        call Trace("major creep attack\n") //xxx
        call MajorCreepAttack()
        return
    endif

    call Trace("minor creep attack\n") //xxx
    call MinorCreepAttack()
endfunction

//============================================================================
/**
@patch 1.00
*/
function GetZeppelin takes nothing returns nothing
    if ready_for_zeppelin then
        set get_zeppelin = true
    endif
endfunction

//============================================================================
/**
@patch 1.00
*/
function FoodUsed takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_USED)
endfunction

//============================================================================
/**
@patch 1.07
*/
function FoodCap takes nothing returns integer
    return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_CAP)
endfunction

//============================================================================
/**
@patch 1.07
*/
function FoodSpace takes nothing returns integer
    return FoodCap() - FoodUsed()
endfunction

//============================================================================
/**
@patch 1.00
*/
function FoodAvail takes integer base returns integer
    return GetFoodMade(racial_farm) * TownCount(racial_farm) + GetFoodMade(base) * TownCount(base)
endfunction

//============================================================================
/**
@patch 1.00
*/
function BuildAttackers takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer desire
    local integer count

    loop
        exitwhen index == harass_length

        set unitid = harass_units[index]
        set desire = harass_qty[index] + IgnoredUnits(unitid)
        set count  = TownCount(unitid)

        if count != desire then
            if not StartUnit(desire,unitid,-1) then
                return
            endif
        endif

        set index = index + 1
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function BuildDefenders takes nothing returns nothing
    local integer index = 0
    local integer unitid
    local integer qty
    loop
        exitwhen index == defense_length

        set unitid = defense_units[index]
        set qty = defense_qty[index]

        call Conversions(qty,unitid)
        call AddDefenders(qty,unitid)

        set index = index + 1
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignBasicsA takes nothing returns nothing
    local integer food_each = GetFoodMade(racial_farm)
    local integer on_wood

    call ClearHarvestAI()

    if CaptainInCombat(false) then
        set on_wood = 0
    else
        set on_wood = campaign_wood_peons
    endif

    call HarvestGold(0,campaign_gold_peons)
    call HarvestWood(0,on_wood)

    if harvest_town1 then
        call HarvestGold(1,campaign_gold_peons)
        call HarvestWood(1,on_wood)
    endif

    if harvest_town2 then
        call HarvestGold(2,campaign_gold_peons)
        call HarvestWood(2,on_wood)
    endif

    if harvest_town3 then
        call HarvestGold(3,campaign_gold_peons)
        call HarvestWood(3,on_wood)
    endif

    if do_campaign_farms and FoodUsed()+food_each-1 > food_each*(TownCount(racial_farm)+1) then
        call StartUnit(TownCount(racial_farm)+1,racial_farm,-1)
    endif

    if build_campaign_attackers then
        call BuildAttackers()
    endif

    if not CaptainInCombat(false) then
        call BuildDefenders()
    endif

    call FillGuardPosts()
    call ReturnGuardPosts()
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignBasics takes nothing returns nothing
    call Sleep(1)
    call CampaignBasicsA()
    call StaggerSleep(1,5)
    loop
        call CampaignBasicsA()
        call Sleep(campaign_basics_speed)
    endloop
endfunction

//============================================================================
/**
@patch 1.00
*/
function CampaignAI takes integer farms, code heroes returns nothing
    if GetGameDifficulty() == MAP_DIFFICULTY_EASY then
        set difficulty = EASY

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_NORMAL then
        set difficulty = NORMAL

        call SetTargetHeroes(false)
        call SetUnitsFlee(false)

    elseif GetGameDifficulty() == MAP_DIFFICULTY_HARD then
        set difficulty = HARD

        call SetPeonsRepair(true)
    else
        set difficulty = INSANE
    endif

    call InitAI()
    call InitBuildArray()
    call InitAssaultGroup()
    call CreateCaptains()

    call SetNewHeroes(false)
    if heroes != null then
        call SetHeroLevels(heroes)
    endif

    call SetHeroesFlee(false)
    call SetGroupsFlee(false)
    call SetSlowChopping(true)
    call GroupTimedLife(false)
    call SetCampaignAI()
    call Sleep(0.1)

    set racial_farm = farms
    call StartThread(function CampaignBasics)
    call StartBuildLoop()
endfunction

//============================================================================
/**
@bug Leaks handle `bldg`: In Jass you must set local variables that hold handles (or any child type) to `null` at the end of functions to avoid leaks.
@patch 1.00
*/
function UnsummonAll takes nothing returns nothing
    local unit bldg
    loop
        set bldg = GetBuilding(ai_player)
        exitwhen bldg==null
        call Unsummon(bldg)
        call Sleep(2)
    endloop
endfunction

//============================================================================
//  SkillArrays
//============================================================================
/**
@patch 1.00
*/
function SkillArrays takes nothing returns integer
    local integer level = GetHeroLevelAI()

    if level > max_hero_level then
        set max_hero_level = level
    endif

    if GetHeroId() == hero_id then
        return skills1[level]
    elseif GetHeroId() == hero_id2 then
        return skills2[level]
    else
        return skills3[level]
    endif
endfunction

//--------------------------------------------------------------------------------------------------
//  SetSkillArray
//--------------------------------------------------------------------------------------------------
/**
@patch 1.07
*/
function SetSkillArray takes integer index, integer id returns nothing
    local integer i = 1

    if index == 1 then
        if hero_id != id then
            return
        endif
        loop
            set skills1[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    elseif index == 2 then
        if hero_id2 != id then
            return
        endif
        loop
            set skills2[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    else
        if hero_id3 != id then
            return
        endif
        loop
            set skills3[i] = skill[i]
            exitwhen i == 10
            set i = i + 1
        endloop
    endif
endfunction

//============================================================================
//  AwaitMeleeHeroes
//============================================================================
/**
@patch 1.00
*/
function AwaitMeleeHeroes takes nothing returns nothing
    if GetUnitCountDone(hero_id2) > 0 then
        set two_heroes = true
    endif
    loop
        exitwhen GetUnitCountDone(hero_id)>0 and (take_exp or (not two_heroes or GetUnitCountDone(hero_id2)>0))
        call Sleep(1)
    endloop
endfunction

//============================================================================
//  PickMeleeHero
//============================================================================
/**
@patch 1.00
*/
function PickMeleeHero takes race raceid returns integer
    local integer first
    local integer second
    local integer third
    local integer last
    local integer array heroes

    //------------------------------------------------------------------------
    if raceid == RACE_HUMAN then
    //------------------------------------------------------------------------
        set heroes[1] = ARCHMAGE
        set heroes[2] = MTN_KING
        set heroes[3] = PALADIN
        set heroes[4] = BLOOD_MAGE

    //------------------------------------------------------------------------
    elseif raceid == RACE_ORC then
    //------------------------------------------------------------------------
        set heroes[1] = BLADE_MASTER
        set heroes[2] = FAR_SEER
        set heroes[3] = TAUREN_CHIEF
        set heroes[4] = SHADOW_HUNTER

    //------------------------------------------------------------------------
    elseif raceid == RACE_NIGHTELF then
    //------------------------------------------------------------------------
        set heroes[1] = DEMON_HUNTER
        set heroes[2] = KEEPER
        set heroes[3] = MOON_BABE
        set heroes[4] = WARDEN

    //------------------------------------------------------------------------
    elseif raceid == RACE_UNDEAD then
    //------------------------------------------------------------------------
        set heroes[1] = DEATH_KNIGHT
        set heroes[2] = DREAD_LORD
        set heroes[3] = LICH
        set heroes[4] = CRYPT_LORD
    else
        set hero_id = 0
    endif

    if VersionCompatible(VERSION_FROZEN_THRONE) then
        set last = 4
    else
        set last = 3
    endif

    set first  = GetRandomInt(1,last)
    set second = GetRandomInt(1,last-1)
    set third  = GetRandomInt(1,last-2)

    set hero_id        = heroes[first]
    set heroes[first]  = heroes[last]
    set hero_id2       = heroes[second]
    set heroes[second] = heroes[last-1]
    set hero_id3       = heroes[third]

    return hero_id
endfunction
